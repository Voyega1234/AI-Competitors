import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import fs from 'fs/promises';
import path from 'path';

// Initialize Supabase client
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || '';
const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || '';
const supabaseAdmin = createClient(supabaseUrl, supabaseKey);

// Helper function to clean Gemini responses from markdown code blocks
export function cleanGeminiResponse(text: string): string {
    // Remove markdown code blocks if present
    if (text.includes('```json') && text.includes('```')) {
        text = text.replace(/```json\n/, '');
        text = text.replace(/```/, '');
    }
    
    // Remove any additional markdown formatting
    text = text.replace(/```/g, '');
    text = text.trim();
    
    return text;
}

// Define interfaces for API responses and data structures
interface RecommendationObject {
  title: string;
  description: string;
  category: string;
  impact: string;
  content_pillar: string;
  product_focus: string;
  concept_idea: string;
  copywriting: {
    headline: string;
    sub_headline_1: string;
    sub_headline_2: string | null;
    bullets: string[];
    cta: string;
  };
  // Optional fields that might be present
  tags?: string[] | null;
  competitiveGap?: string | null;
  purpose_th?: string;
  target_audience_th?: string;
  context_th?: string;
  constraints_th?: string;
  competitors_th?: string;
  untapped_potential_th?: string;
  promoted_product_th?: string;
  mood_and_tone_th?: string;
  key_message_th?: string;
  execution_example_th?: string;
}

// Define the structure for a recommendation generated by Gemini
interface GeneratedRecommendation {
    title: string;
    description: string;
    category: string; // e.g., Campaign, Promotion, Content, Feature, Initiative
    impact: string;   // e.g., High, Medium, Low
    competitiveGap?: string | null;
    tags?: string[] | null;
    // --- Add Thai Strategic Analysis Fields ---
    purpose_th?: string;       // ๑. รู้เป้าหมาย
    target_audience_th?: string; // ๒. รู้คนฟัง/คนใช้
    context_th?: string;         // ๓. รู้บริบท
    constraints_th?: string;     // ๔. รู้ข้อจำกัด
    competitors_th?: string;     // ๕. รู้ว่าใครทำอะไรไปแล้ว
    untapped_potential_th?: string; // ๖. รู้ว่าอะไร "ยังไม่มีใครกล้าทำ"
}

// Expected structure from the Gemini JSON response
interface GeminiRecommendationOutput {
    recommendations: GeneratedRecommendation[];
}

// Define the path to the book summaries directory (should match the one in /api/book-summaries)
const booksDirectory = path.join(process.cwd(), 'src', 'app', 'api', 'generate-recommendations', 'books_prompts');

// Function to get ad pillars data from Supabase
const getAdPillars = async (adAccountId?: string) => {
  try {
    let query = supabaseAdmin
      .from('ads_details')
      .select('creative_pillars')
      .not('creative_pillars', 'is', null);
    
    // Add ad account filter if provided
    if (adAccountId) {
      query = query.eq('ad_account_id', adAccountId);
    }
    
    const { data: ads, error } = await query;

    if (error) throw error;
    if (!ads || ads.length === 0) return [];

    const pillarCounts: Record<string, number> = {};
    
    ads.forEach((ad: { creative_pillars: string }) => {
      if (ad.creative_pillars) {
        try {
          // Parse the PostgreSQL array format
          const pillars = ad.creative_pillars
            .slice(1, -1) // Remove outer {}
            .split(',')
            .map((p: string) => {
              // Clean up the pillar text
              let pillar = p.trim();
              if (pillar.startsWith('"') && pillar.endsWith('"')) {
                pillar = pillar.slice(1, -1);
              }
              return pillar;
            });
          
          // Count occurrences
          pillars.forEach((pillar: string) => {
            if (pillar) {
              pillarCounts[pillar] = (pillarCounts[pillar] || 0) + 1;
            }
          });
        } catch (e) {
          console.error('Error parsing pillars:', e);
        }
      }
    });

    // Convert to array and sort by count
    return Object.entries(pillarCounts)
      .map(([pillar, count]) => ({ pillar, count: count as number }))
      .sort((a, b) => b.count - a.count);
  } catch (error) {
    console.error('Error fetching ad pillars:', error);
    return [];
  }
};

// Function to build the final user prompt with all necessary parameters
const buildFinalUserPrompt = async (
  clientName: string,
  market: string,
  productFocus: string | null,
  userBrief: string,
  groundedInfo: string,
  bookSummaryContent: string,
  competitorAnalysisText: string,
  taskSectionParam: string | null,
  detailsSectionParam: string | null,
  adAccountId?: string
) => {
  const groundedSection = groundedInfo ? `
---
*(This section provides recent context about ${clientName}. Consider these details alongside the core client information to ensure recommendations are timely and relevant. Use specific points from here where they offer a clear advantage or fresh angle.)*
` : '';

  // Only include competitor section if text is provided and doesn't contain errors
  const competitorSection = competitorAnalysisText && !competitorAnalysisText.toLowerCase().includes('error')
    ? `
**Market Research & Insights (Google Search):**
${competitorAnalysisText}
`
    : '';

  // Get ad pillars data and create analysis section
  const adPillars = await getAdPillars(adAccountId);
  const adPillarsSection = adPillars.length > 0
    ? `
**Current Ad Pillar Analysis:**
Here are the creative pillars currently being used in our ads, along with their frequency:
${adPillars.map(p => `- ${p.pillar}: ${p.count} ads`).join('\n')}

**Creative Strategy Guidance:**
1. Consider prioritizing ideas that utilize underutilized pillars (those with lower counts)
2. For each recommendation, suggest which pillar(s) it aligns with from our existing set
3. If introducing a new pillar, explain how it complements our current strategy
4. Consider combining multiple pillars in innovative ways to create unique concepts

**Pillar-Specific Considerations:**
- For "Problem Solution" pillars: Focus on clear pain points and solutions
- For "Feature Showcase" pillars: Highlight unique product features with strong visuals
- For "Educational" pillars: Provide valuable, informative content
- For "Testimonial/Social Proof" pillars: Incorporate authentic customer stories
`
    : '';

  // Default task section if not provided
  const defaultTaskSection = `1. Spark and detail 7-10 fresh, distinctive, and engaging creative ideas for ${clientName}, specifically focusing on concepts highly suitable for Facebook Ad campaigns. Focus on concepts that can present the client's specific ${productFocus || 'products/services'} from new perspectives that spark curiosity, drive engagement, or create a memorable impression within the ${market} on social media. Ideas should build upon the client's strengths and available insights.
  2. Focus on Actionable Creativity for Facebook: Ensure each recommendation translates into tangible marketing ideas easily adaptable into compelling Facebook Ad formats (e.g., single image/video, carousel, stories, reels). Include potential ad angles, visual directions, and calls-to-action. Prioritize ideas that are visually arresting, memorable, shareable, emotionally resonant, and push creative boundaries for this specific client on Facebook.
  3. Informed by Context: Where available, let the \`groundedClientInfo\` and \`bookSummarySection\` inform the relevance, timeliness, or strategic angle of your ideas, but the core inspiration should stem from the client's fundamental product/service and market position. Use grounding to verify trends or competitor actions if needed.
  4. For EACH recommendation, provide the Creative Execution Details below, specifically tailored for a Facebook Ad context. Generate specific, compelling content for each field IN THAI LANGUAGE, imagining how the core idea translates into ad components (e.g., Headline, Ad Copy, Visual Description, Call-to-Action).
  5. Populate the corresponding fields in the final JSON object. Ensure all text output is original for this request
  6. Ideas to include but not limited to: why the solutions from ${clientName} are different than what is being offered in the market currently. Talk about the differentiation of the product if and when it makes the client's product or service more appealing.`;

  // Default details section if not provided
  const defaultDetailsSection = `a.  **\`content_pillar\`:** กำหนดธีมเนื้อหาหลักหรือหมวดหมู่ **(ภาษาไทย)** (เช่น "เคล็ดลับฮาวทู", "เบื้องหลังการทำงาน", "เรื่องราวความสำเร็จลูกค้า", "การหักล้างความเชื่อผิดๆ", "ไลฟ์สไตล์และการใช้งาน", "ปัญหาและการแก้ไข").
  b.  **\`product_focus\`:** ระบุ ${productFocus || 'ผลิตภัณฑ์/บริการ'} ที่ต้องการเน้น **(ภาษาไทย)**.
  c.  **\`concept_idea\`:** สรุปแนวคิดสร้างสรรค์หลัก (1-2 ประโยค) สำหรับการนำเสนอไอเดียนี้ **(ภาษาไทย)**.
  d.  **\`copywriting\`:** สร้างสรรค์องค์ประกอบข้อความโฆษณาเบื้องต้น **(ภาษาไทย)**:
      *   **\`headline\`:** พาดหัวที่ดึงดูดความสนใจ **(ภาษาไทย)**.
      *   **\`sub_headline_1\`:** พาดหัวรองที่ขยายความหรือเน้นประโยชน์ **(ภาษาไทย)**.
      *   **\`sub_headline_2\`:** พาดหัวรองที่สอง (ถ้ามี) เพื่อเพิ่มบริบทหรือความเร่งด่วน **(ภาษาไทย)** (ใช้ \`null\` หากไม่ต้องการ).
      *   **\`bullets\`:** รายการจุดเด่น 2-4 ข้อที่เน้นประโยชน์หลัก, ฟีเจอร์ หรือเหตุผลที่น่าเชื่อถือ **(ภาษาไทย)**.
      *   **\`cta\`:** ข้อความเรียกร้องให้ดำเนินการ (Call To Action) ที่ชัดเจน **(ภาษาไทย)** (เช่น "เรียนรู้เพิ่มเติม", "ซื้อเลย", "ดูเดโม", "เข้าร่วม Waiting List", "ดาวน์โหลดคู่มือ").`;

  return `
Analyze the following client information, recent grounded search results (if available), competitor summary, ad pillar analysis, and optional book context to conceptualize groundbreaking creative recommendations and their initial execution details IN THAI.
ALL TEXTUAL OUTPUT IN THE FINAL JSON RESPONSE MUST BE IN THAI.
Crucially, leverage your access to real-time information via search grounding (if applicable to the model/call) to ensure ideas are timely, relevant, and informed by the latest digital landscape.
You have no limits to your creativity. You are free.

**Client Information:**
*   Name: ${clientName}
*   Market: ${market}
*   Product Focus: ${productFocus || 'N/A'}
${userBrief ? `
**Additional User Brief/Context:**
${userBrief}
` : ''}
${groundedSection}

${bookSummaryContent ? `
**Optional Book Summary Contexts:**
You can use these principles or frameworks from books to help create impactful and outstanding ideas:
${bookSummaryContent}
` : ''}

**Task:**
${taskSectionParam || defaultTaskSection}

${competitorSection}

${adPillarsSection}

**Creative Execution Details (Per Recommendation - Populate these fields IN THAI for the JSON):**
${detailsSectionParam || defaultDetailsSection}

// ... rest of the JSON output format requirements ...
`;
};

// Helper function to create a concise summary of competitor data
function summarizeCompetitors(competitors: Competitor[]): string {
    if (!competitors || competitors.length === 0) {
        return "No competitor data available.";
    }

    let summary = `Analysis of ${competitors.length} competitors reveals:\n`;

    // --- Basic Service Overview ---
    const allServices = new Set<string>();
    competitors.forEach(c => c.services?.forEach(s => allServices.add(s.toLowerCase())));
    if (allServices.size > 0) {
        summary += `- Common service areas include: ${Array.from(allServices).slice(0, 5).join(', ')}${allServices.size > 5 ? '...' : ''}.\n`;
    }

    // --- Pricing Insights (Example) ---
    const pricingModels = new Set<string>();
    competitors.forEach(c => { if (c.pricing) pricingModels.add(c.pricing); });
    if (pricingModels.size > 0) {
        summary += `- Pricing models observed: ${Array.from(pricingModels).slice(0, 3).join(', ')}.\n`;
    }
    
    // --- Strengths/Weaknesses (Example) ---
    const commonStrengths = new Map<string, number>();
    const commonWeaknesses = new Map<string, number>();
    competitors.forEach(c => {
        c.strengths?.forEach(s => commonStrengths.set(s.toLowerCase(), (commonStrengths.get(s.toLowerCase()) || 0) + 1));
        c.weaknesses?.forEach(w => commonWeaknesses.set(w.toLowerCase(), (commonWeaknesses.get(w.toLowerCase()) || 0) + 1));
    });
    // Helper to get top N items from a map
    const getTopItems = (map: Map<string, number>, topN: number) => Array.from(map.entries())
                                                                          .sort((a, b) => b[1] - a[1])
                                                                          .slice(0, topN)
                                                                          .map(entry => entry[0]);

    const topStrengths = getTopItems(commonStrengths, 2);
    const topWeaknesses = getTopItems(commonWeaknesses, 2);
    if (topStrengths.length > 0) summary += `- Common competitor strengths: ${topStrengths.join(', ')}.\n`;
    if (topWeaknesses.length > 0) summary += `- Common competitor weaknesses: ${topWeaknesses.join(', ')}.\n`;

    // Add more summary points as needed (e.g., target audience, market share hints)

    return summary;
}

// Define a basic Competitor type matching Supabase table structure (adjust if needed)
interface Competitor {
  id: string; // Or number depending on your schema
  analysisRunId: string; // Foreign key
  name?: string | null;
  services?: string[] | null;
  pricing?: string | null;
  strengths?: string[] | null;
  weaknesses?: string[] | null;
  targetAudience?: string | null;
  // Add other fields from your Competitor table
}

// Define AnalysisRun type matching Supabase table structure (adjust if needed)
interface AnalysisRun {
  id: string;
  clientName: string;
  market: string;
  productFocus: string | null;
  ad_account_id?: string | null;
  // Add other fields from your AnalysisRun table
}

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;
  const runId = searchParams.get('runId');
  const userBrief = searchParams.get('brief');
  const taskSectionParam = searchParams.get('taskSection');
  const detailsSectionParam = searchParams.get('detailsSection');
  // const bookFilenamesParam = searchParams.get('bookFilenames'); // REMOVED - Now reading all books
  const modelsParam = searchParams.get('models'); // NEW: Read models parameter
  const includeCompetitorAnalysis = searchParams.get('includeCompetitorAnalysis') !== 'false';
  const GEMINI_API_KEY = process.env.NEXT_PUBLIC_GEMINI_API_KEY;
  const OPENAI_API_KEY = process.env.NEXT_PUBLIC_OPENAI_API_KEY; // Read OpenAI Key
  const ANTHROPIC_API_KEY = process.env.NEXT_PUBLIC_ANTHROPIC_API_KEY; // Read Anthropic Key

  // TODO: Add OPENAI_API_KEY and CLAUDE_API_KEY later

  // --- Validation ---
  if (!runId) {
    return new NextResponse(JSON.stringify({ error: 'runId query parameter is required' }), { status: 400 });
  }
  if (!modelsParam) {
    return new NextResponse(JSON.stringify({ error: 'models query parameter is required' }), { status: 400 });
  }
  const requestedModels = modelsParam.split(',').map(m => m.trim().toLowerCase()); // Parse and normalize
  if (requestedModels.length === 0) {
    return new NextResponse(JSON.stringify({ error: 'No models specified in models parameter' }), { status: 400 });
  }
  if (requestedModels.includes('gemini') && !GEMINI_API_KEY) {
    console.error("GEMINI_API_KEY is not set.");
    return new NextResponse(JSON.stringify({ error: 'Server configuration error: Missing Gemini API key.' }), { status: 500 });
  }
  if (requestedModels.includes('openai') && !OPENAI_API_KEY) { // Check for OpenAI key
    console.error("OPENAI_API_KEY is not set.");
    return new NextResponse(JSON.stringify({ error: 'Server configuration error: Missing OpenAI API key.' }), { status: 500 });
  }
  if (requestedModels.includes('claude') && !ANTHROPIC_API_KEY) { // Check for Anthropic key
    console.error("ANTHROPIC_API_KEY is not set.");
    return new NextResponse(JSON.stringify({ error: 'Server configuration error: Missing Anthropic API key.' }), { status: 500 });
  }
  // TODO: Add checks for OpenAI/Claude keys when implemented

  console.log(`Handling GET /api/generate-recommendations for runId: ${runId}, Models: ${requestedModels.join(', ')}`);

  // --- Initialize result holders ---
  const finalResults: Record<string, any> = {};
  const finalErrors: Record<string, any> = {};

  try {
    // --- Fetch common data (needed by all models) ---
    const { data: analysisRunData, error: runError } = await supabaseAdmin
        .from('AnalysisRun') // Ensure table name is correct
        .select('*')
        .eq('id', runId)
        .single(); // Fetch a single record

    if (runError && runError.code !== 'PGRST116') { // Ignore "Row not found" error here
        console.error(`Supabase error fetching AnalysisRun ${runId}:`, runError);
        throw new Error(runError.message || 'Failed to fetch analysis run data');
    }

    if (!analysisRunData) {
        console.log(`AnalysisRun not found for runId: ${runId}`);
        return new NextResponse(
            JSON.stringify({ error: 'Analysis run not found' }),
            { status: 404, headers: { 'Content-Type': 'application/json' } }
        );
    }

    // 2. Fetch associated Competitors using Supabase
    const { data: competitorsData, error: competitorError } = await supabaseAdmin
        .from('Competitor') // Ensure table name is correct
        .select('*')
        .eq('analysisRunId', runId); // Filter by the foreign key

    if (competitorError) {
        console.error(`Supabase error fetching Competitors for runId ${runId}:`, competitorError);
        throw new Error(competitorError.message || 'Failed to fetch competitor data');
    }

    // --- Fetch and Concatenate ALL Book Summary Content ---
    let bookSummaryContent = '';
    console.log(`Attempting to read ALL book summaries from: ${booksDirectory}`);
    try {
        const allFiles = await fs.readdir(booksDirectory);
        const bookFiles = allFiles.filter(file => file.match(/\.(txt|md)$/i)); // Filter for .txt or .md
        console.log(`Found ${bookFiles.length} potential book summary files.`);
        let summaries: string[] = [];

        for (const filename of bookFiles) {
            const filePath = path.join(booksDirectory, filename);
            try {
                const content = await fs.readFile(filePath, 'utf-8');
                console.log(`Successfully read ${filename}`);
                summaries.push(`--- Start Summary: ${filename} ---\n${content}\n--- End Summary: ${filename} ---`);
            } catch (fileError: any) {
                console.error(`Error reading book summary file ${filePath}:`, fileError);
                // Skip this file if error reading, but log it
            }
        }
        bookSummaryContent = summaries.join('\n\n'); 
        console.log(`Total combined book summary length: ${bookSummaryContent.length}`);
    } catch (dirError: any) {
        if (dirError.code === 'ENOENT') {
            console.warn(`Book summaries directory not found: ${booksDirectory}. Proceeding without book context.`);
        } else {
            console.error(`Error reading book summaries directory ${booksDirectory}:`, dirError);
        }
        // Proceed without book summaries if directory reading fails
    }
    // --- End Book Summary Fetch ---

    // --- Perform Grounding Search (Run ONCE if Gemini Key exists, used by all models) ---
    let groundedClientInfoCommon = '';
    let competitorAnalysisData = '';
    
    if (GEMINI_API_KEY) { // Only attempt grounding if the key is available
        // Only fetch competitor analysis if it's enabled
        if (includeCompetitorAnalysis) {
            try {
                console.log(`[Refactor] Fetching competitor analysis from Supabase for client: ${analysisRunData.clientName}, product: ${analysisRunData.productFocus}`);
                
                const { data: allAnalysisData, error } = await supabaseAdmin
                    .from('competitor_analysis')
                    .select('analysis_data, client_name, product_focus, created_at')
                    .eq('client_name', analysisRunData.clientName.trim())
                    .eq('product_focus', (analysisRunData.productFocus || '').trim())
                    .order('created_at', { ascending: false });

                if (error) {
                    console.error('[DB Query] Supabase error:', {
                        message: error.message,
                        code: error.code,
                        details: error.details,
                        hint: error.hint
                    });
                    throw error;
                }

                if (!allAnalysisData || allAnalysisData.length === 0) {
                    console.warn('[DB Query] No analysis data found for:', {
                        client: analysisRunData.clientName,
                        product: analysisRunData.productFocus
                    });
                    competitorAnalysisData = '## Market Research & Insights\nNo research data available.\n';
                } else {
                    const latestAnalysis = allAnalysisData[0];
                    console.log('[DB Query] Found data:', {
                        client_name: latestAnalysis.client_name,
                        product_focus: latestAnalysis.product_focus,
                        created_at: latestAnalysis.created_at,
                        data_keys: latestAnalysis.analysis_data ? Object.keys(latestAnalysis.analysis_data) : []
                    });
                    
                    // Log the complete analysis_data structure for debugging
                    console.log('Raw analysis_data structure:', JSON.stringify(latestAnalysis.analysis_data, null, 2));
                    
                    // Use the raw analysis_data as-is
                    if (latestAnalysis.analysis_data) {
                        // If it's already a string, use it directly
                        if (typeof latestAnalysis.analysis_data === 'string') {
                            competitorAnalysisData = `## Market Research & Insights\n${latestAnalysis.analysis_data}`;
                        } 
                        // If it's an object, stringify it with pretty print
                        else if (typeof latestAnalysis.analysis_data === 'object') {
                            competitorAnalysisData = `## Market Research & Insights\n${JSON.stringify(latestAnalysis.analysis_data, null, 2)}`;
                        }
                    } else {
                        competitorAnalysisData = '## Market Research & Insights\nNo research data available.\n';
                    }
                }
            } catch (error) {
                console.error("[Refactor] Error fetching competitor analysis from Supabase:", error);
                // Proceed without competitor analysis if fetch fails
            }
        } else {
            console.log('[Refactor] Skipping competitor analysis fetch as it is disabled');
        }
        
        // Then perform grounding search as before
        const groundingPrompt = `ขอข้อมูลของ ${analysisRunData.clientName} ข้อมูลอัพเดทล่าสุด อยากได้ข้อมูลเช่น ราคา-ค่าใช้จ่าย, จุดเด่น ข้อมูลสำคัญต่างๆ โปรโมชั่น หรือ กิจกรรมและแคมเปญล่าสุด อยากได้ข้อมูลที่สดใหม่ที่สุด ตอบแค่คำตอบเท่านั้นห้ามตลอดอะไรมากกว่านี้`;
        console.log(`[Refactor] Performing common grounding search for client: ${analysisRunData.clientName}`);
        try {
            const groundingPayload = {
                contents: [{ parts: [{ text: groundingPrompt }] }],
                tools: [{ "google_search": {} }],
                generationConfig: { temperature: 0.2 } // Low temp for factual retrieval
            };
            const groundingGeminiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`; // Use Flash for grounding
            const groundingResponse = await fetch(groundingGeminiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(groundingPayload)
            });

            if (!groundingResponse.ok) {
                const errorText = await groundingResponse.text();
                console.warn(`[Refactor] Common grounding search failed (${groundingResponse.status}): ${errorText}`);
            } else {
                const groundingData = await groundingResponse.json();
                // Check tool calls response structure (adjust logic based on actual Gemini response format for tool calls)
                const functionResponse = groundingData?.candidates?.[0]?.content?.parts?.find((part: any) => part.functionResponse);
                if (functionResponse?.functionResponse?.name === 'google_search') { // More specific check
                     groundedClientInfoCommon = functionResponse.functionResponse.text || ''; // Adjust based on actual structure
                     console.log(`[Refactor] Common grounding successful via tool call. Length: ${groundedClientInfoCommon.length}`);
                } else {
                     // Fallback: check for direct text response (less likely)
                     groundedClientInfoCommon = groundingData?.candidates?.[0]?.content?.parts?.[1]?.text?.trim() || '';
                     if (groundedClientInfoCommon) {
                         console.log(`[Refactor] Common grounding returned direct text (fallback). Length: ${groundedClientInfoCommon.length}`);
                     } else {
                         console.log(`[Refactor] Common grounding completed, but NO relevant text found in response.`);
                     }
                }
            }
        } catch (groundingError: any) {
            console.error("[Refactor] Error during common grounding search:", groundingError);
            // Proceed without grounding info if search fails
        }
    } else {
        console.log("[Refactor] Skipping common grounding search as Gemini API key is not set.");
    }
    // --- End Grounding Search ---

    // --- Function to build the final user prompt (dynamically includes grounded info and ad pillars) ---
    const buildFinalUserPrompt = async (groundedInfo: string, competitorAnalysisText: string = '', includeCompetitorAnalysis: boolean = true) => {
        const groundedSection = groundedInfo ? `
---
*(This section provides recent context about ${analysisRunData.clientName}. Consider these details alongside the core client information to ensure recommendations are timely and relevant. Use specific points from here where they offer a clear advantage or fresh angle.)*
` : '';

        // Only include competitor analysis if the flag is true and the text is valid
        const competitorSection = (includeCompetitorAnalysis && 
                                 competitorAnalysisText && 
                                 !competitorAnalysisText.toLowerCase().includes('error'))
            ? `
**Market Research & Insights (Google Search):**
${competitorAnalysisText}
`
            : '';

        // Get ad pillars data
        let adPillarsSection = '';
        try {
            const adPillars = await getAdPillars();
            if (adPillars.length > 0) {
                adPillarsSection = `
**Current Ad Pillar Analysis:**
Here are the creative pillars currently being used in our ads, along with their frequency:
${adPillars.map(p => `- ${p.pillar}: ${p.count} ads`).join('\n')}

**Creative Strategy Guidance:**
1. Consider prioritizing ideas that utilize underutilized pillars (those with lower counts)
2. For each recommendation, suggest which pillar(s) it aligns with from our existing set
3. If introducing a new pillar, explain how it complements our current strategy
4. Consider combining multiple pillars in innovative ways to create unique concepts

**Pillar-Specific Considerations:**
- For "Problem Solution" pillars: Focus on clear pain points and solutions
- For "Feature Showcase" pillars: Highlight unique product features with strong visuals
- For "Educational" pillars: Provide valuable, informative content
- For "Testimonial/Social Proof" pillars: Incorporate authentic customer stories
`;
            }
        } catch (error) {
            console.error('Error generating ad pillars section:', error);
            adPillarsSection = '\n*Error loading ad pillar data. Proceeding without it.*';
        }


        return `

Analyze the following client information, recent grounded search results (if available), competitor summary, and optional book context to conceptualize groundbreaking creative recommendations and their initial execution details IN THAI.
ALL TEXTUAL OUTPUT IN THE FINAL JSON RESPONSE MUST BE IN THAI.
Crucially, leverage your access to real-time information via search grounding (if applicable to the model/call) to ensure ideas are timely, relevant, and informed by the latest digital landscape.
You have no limits to your creativity. You are free.

**Client Information:**
*   Name: ${analysisRunData.clientName}
*   Market: ${analysisRunData.market}
*   Product Focus: ${analysisRunData.productFocus}
${userBrief ? `
**Additional User Brief/Context:**
${userBrief}
` : ''}
${groundedSection}

${bookSummaryContent ? `
**Optional Book Summary Contexts:**
ํYou can use these principle or framework from book to help you create impactfull and outstanding ideas
${bookSummaryContent}
` : ''}

**Task:**
${taskSectionParam ? taskSectionParam.replace(/\{clientName\}/g, analysisRunData.clientName).replace(/\{market\}/g, analysisRunData.market).replace(/\{productFocus\}/g, analysisRunData.productFocus || 'products/services') :
 `1. Spark and detail 7-10 fresh, distinctive, and engaging creative ideas for ${analysisRunData.clientName}, specifically focusing on concepts highly suitable for Facebook Ad campaigns. Focus on concepts that can present the client's specific ${analysisRunData.productFocus} from new perspectives that spark curiosity, drive engagement, or create a memorable impression within the ${analysisRunData.market} on social media. Ideas should build upon the client's strengths and available insights.
  2. Focus on Actionable Creativity for Facebook: Ensure each recommendation translates into tangible marketing ideas easily adaptable into compelling Facebook Ad formats (e.g., single image/video, carousel, stories, reels). Include potential ad angles, visual directions, and calls-to-action. Prioritize ideas that are visually arresting, memorable, shareable, emotionally resonant, and push creative boundaries for this specific client on Facebook.
  3. Informed by Context: Where available, let the \`groundedClientInfo\` and \`bookSummarySection\` inform the relevance, timeliness, or strategic angle of your ideas, but the core inspiration should stem from the client's fundamental product/service and market position. Use grounding to verify trends or competitor actions if needed.
  4. For EACH recommendation, provide the Creative Execution Details below, specifically tailored for a Facebook Ad context. Generate specific, compelling content for each field IN THAI LANGUAGE, imagining how the core idea translates into ad components (e.g., Headline, Ad Copy, Visual Description, Call-to-Action).
  5. Populate the corresponding fields in the final JSON object. Ensure all text output is original for this request
  6. Ideas to include but not limited to: why the solutions from ${analysisRunData.clientName} are different than what is being offered in the market currently. Talk about the differentiation of the product if and when it makes the client's product or service more appealing. 
  7. Competitor Analysis is important please use it to make a strategic idea.`}

**Market Research & Insights (Google Search):**
${competitorSection}

${adPillarsSection}

** Your Ideas should be mix with News and Trending topics in Thailand in Market Research & Insights to make ideas fresh and relevant on time.
  
**Creative Execution Details (Per Recommendation - Populate these fields IN THAI for the JSON):**
${detailsSectionParam ? detailsSectionParam.replace(/\{productFocus\}/g, analysisRunData.productFocus || 'products/services') : `a.  **\`content_pillar\`:** กำหนดธีมเนื้อหาหลักหรือหมวดหมู่ **(ภาษาไทย)** (เช่น "เคล็ดลับฮาวทู", "เบื้องหลังการทำงาน", "เรื่องราวความสำเร็จลูกค้า", "การหักล้างความเชื่อผิดๆ", "ไลฟ์สไตล์และการใช้งาน", "ปัญหาและการแก้ไข").
                                b.  **\`product_focus\`:** ระบุ ${analysisRunData.productFocus || 'ผลิตภัณฑ์/บริการ'} ที่ต้องการเน้น **(ภาษาไทย)**.
                                c.  **\`concept_idea\`:** สรุปแนวคิดสร้างสรรค์หลัก (1-2 ประโยค) สำหรับการนำเสนอไอเดียนี้ **(ภาษาไทย)**.
                                d.  **\`copywriting\`:** สร้างสรรค์องค์ประกอบข้อความโฆษณาเบื้องต้น **(ภาษาไทย)**:
                                    *   **\`headline\`:** พาดหัวที่ดึงดูดความสนใจ **(ภาษาไทย)**.
                                    *   **\`sub_headline_1\`:** พาดหัวรองที่ขยายความหรือเน้นประโยชน์ **(ภาษาไทย)**.
                                    *   **\`sub_headline_2\`:** พาดหัวรองที่สอง (ถ้ามี) เพื่อเพิ่มบริบทหรือความเร่งด่วน **(ภาษาไทย)** (ใช้ \`null\` หากไม่ต้องการ).
                                    *   **\`bullets\`:** รายการจุดเด่น 2-4 ข้อที่เน้นประโยชน์หลัก, ฟีเจอร์ หรือเหตุผลที่น่าเชื่อถือ **(ภาษาไทย)**.
                                    *   **\`cta\`:** ข้อความเรียกร้องให้ดำเนินการ (Call To Action) ที่ชัดเจน **(ภาษาไทย)** (เช่น "เรียนรู้เพิ่มเติม", "ซื้อเลย", "ดูเดโม", "เข้าร่วม Waiting List", "ดาวน์โหลดคู่มือ").`}

                                Ensure your copy aligns with modern, high-quality advertising standards and is tailored to effectively resonate with the specific target audience provided

**Output Format Requirements (CRITICAL):**
*   YOU MUST RETURN PURE RAW JSON WITHOUT ANY MARKDOWN CODE BLOCKS. DO NOT WRAP IN CODE BLOCKS.
*   Output ONLY a valid JSON object. NO markdown formatting, NO triple backticks, NO explanation, NO introduction, and NO trailing text.
*   All property names and string values must use double quotes (").
*   The JSON object MUST strictly follow the structure below.
*   If a value is missing, use null or an empty string.
*   Do NOT include any comments or extra fields.
*   IMPORTANT: NEVER WRAP YOUR RESPONSE IN CODE BLOCKS. RETURN ONLY THE RAW JSON.
*   *   **Crucially, the values for \`content_pillar\`, \`product_focus\`, \`concept_idea\`, and all fields within \`copywriting\` (\`headline\`, \`sub_headline_1\`, \`sub_headline_2\`, \`bullets\`, \`cta\`) MUST be generated in THAI LANGUAGE.**
*   \`title\` and \`description\` fields should also be generated in THAI LANGUAGE.
*   Use "High", "Medium", or "Low" for the impact field (bias towards "High").
*   Provide a concise "competitiveGap" string (in THAI LANGUAGE).
*   Include 2-4 relevant and specific keyword strings in the "tags" array (in THAI LANGUAGE).

Example output (strictly follow this format, with double quotes and valid JSON):
{
  "recommendations": [
    {
      "title": " title ควรเป็น Coreconcept ที่ Summarize มาจาก Description เช่น LingoAce: ปูพื้นฐานภาษาอังกฤษที่สนุกและอ่อนโยนสำหรับเด็ก 3-6 ปี จาก description "details : "แคมเปญเจาะกลุ่มผู้ปกครองเด็กเล็ก (3-6 ปี) โดยเฉพาะ เน้นความอ่อนโยน ความสนุก และวิธีการสอนที่เหมาะสมกับพัฒนาการของเด็กเล็ก เพื่อสร้างความคุ้นเคยและทัศนคติที่ดีต่อการเรียนภาษาตั้งแต่เนิ่นๆ อ้างอิงข้อมูลที่ LingoAce เหมาะสำหรับเด็กอายุ 3-15 ปี และเทรนด์การปูพื้นฐานภาษาตั้งแต่ปฐมวัย"
      "description": "รายละเอียดแนวคิดสร้างสรรค์ ที่ไม่ซ้ำใคร และมีประสิทธิภาพ (ภาษาไทย) อย่างละเอียด", // Thai - Must be original
      "category": "Campaign", // Keep category identifier standard
      "impact": "High",
      "competitiveGap": "ระบุช่องว่างทางการแข่งขันที่ไอเดียนี้เข้าไปตอบโจทย์ (ภาษาไทย)", // Thai - Must be original
      "tags": ["คำค้น1", "คำค้น2", "รูปแบบเนื้อหา"], // Thai - Must be original
      "content_pillar": "ตัวอย่าง: เคล็ดลับฮาวทู", // Thai - Must be original
      "product_focus": "ระบุ ${analysisRunData.productFocus || 'ผลิตภัณฑ์/บริการ'} ที่ระบุใน Input", // Thai - Must be original & specific to input
      "concept_idea": "สรุปแนวคิด Coreconcept ของไอเดียนี้ (1-2 ประโยค)", // Thai - Must be original
      "copywriting": {
        "headline": "พาดหัวหลักที่ดึงดูดความสนใจ", // Thai - Must be original
        "sub_headline_1": "พาดหัวรองที่ขยายความหรือเน้นประโยชน์", // Thai - Must be original
        "sub_headline_2": "พาดหัวรองที่สอง (ถ้ามี) หรือ null", // Thai - Must be original or null
        "bullets": [
          "จุดเด่นที่ 1", // Thai - Must be original
          "จุดเด่นที่ 2", // Thai - Must be original
          "จุดเด่นที่ 3"  // Thai - Must be original
        ],
        "cta": "ตัวอย่าง: ดูเพิ่มเติม" // Thai - Must be original
      }
    }
    // ... more recommendation objects (7-10 total)
  ]
}

Return ONLY the JSON object above, nothing else.
`;
    };

    // ... (rest of the code remains the same)
    const useModelCompetition = false;

    // Step 1: Initial generation with Gemini
    // Step 2: Pass Gemini's output to GPT-4.1 with challenge prompt
    // Step 3: Pass GPT's output back to Gemini with competitive prompt

    let initialGeminiOutput: any[] = [];
    let gptImprovedOutput: any[] = [];
    let finalGeminiOutput: any[] = [];
    
    // Only run Gemini if it's specifically requested or if model competition is enabled
    const shouldRunGemini = requestedModels.includes('gemini') || useModelCompetition;
    // Only run OpenAI if it's specifically requested (and not running through model competition)
    const shouldRunOpenAI = requestedModels.includes('openai');
    // Only run Claude if it's specifically requested (and not running through model competition)
    const shouldRunClaude = requestedModels.includes('claude');

    // If only a specific model is requested and not Gemini, skip the competition workflow
    if (!shouldRunGemini && (shouldRunOpenAI || shouldRunClaude)) {
        console.log(`Skipping Gemini and running only the requested model(s): ${requestedModels.join(', ')}`);
    } else {
        console.log("Starting Model Competition Workflow...");
    }

    // --- STEP 1: Initial Gemini Generation (only if requested or part of competition) ---
    if (shouldRunGemini) {
        console.log("STEP 1: Starting initial Gemini generation...");
        try {
        // --- Prepare Gemini Prompt (using common builder) ---
        console.log('Debug - buildFinalUserPrompt parameters:', {
          clientName: analysisRunData.clientName,
          market: analysisRunData.market,
          productFocus: analysisRunData.productFocus,
          userBrief: userBrief || '',
          groundedInfo: groundedClientInfoCommon?.substring(0, 100) + '...', // Log first 100 chars
          bookSummaryContent: bookSummaryContent?.substring(0, 100) + '...', // Log first 100 chars
          competitorAnalysisText: includeCompetitorAnalysis ? (competitorAnalysisData?.substring(0, 100) + '...') : 'None',
          taskSectionParam: taskSectionParam,
          detailsSectionParam: detailsSectionParam,
          adAccountId: analysisRunData.ad_account_id || 'None'
        });

        const finalGeminiPrompt = await buildFinalUserPrompt(
          typeof groundedClientInfoCommon === 'string' ? groundedClientInfoCommon : '', // groundedInfo
          (includeCompetitorAnalysis && competitorAnalysisData) ? competitorAnalysisData : '', // competitorAnalysisText
          includeCompetitorAnalysis // includeCompetitorAnalysis
        );
        
        console.log('Competitor analysis data being passed to prompt:', 
          (includeCompetitorAnalysis && competitorAnalysisData) ? 'Data exists' : 'No data');
        
        console.log('Debug - buildFinalUserPrompt completed successfully');

        // --- Log Gemini Prompt ---
        console.log("--- START INITIAL GEMINI PROMPT ---");
        console.log(finalGeminiPrompt);
        console.log("--- END INITIAL GEMINI PROMPT ---");

        // --- Call Gemini API ---
        console.log("Sending initial request to Gemini API...");
        const geminiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro-preview-05-06:generateContent?key=${GEMINI_API_KEY}`;
        const geminiPayload = {
            contents: [{ parts: [{ text: finalGeminiPrompt }] }],
            generationConfig: { 
                temperature: 1.0,
            },
            // tools: [{ "google_search": {} }]
        };

        const geminiResponse = await fetch(geminiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(geminiPayload)
        });

        if (!geminiResponse.ok) {
            const errorText = await geminiResponse.text();
            throw new Error(`Initial Gemini API request failed: ${geminiResponse.status} - ${errorText}`);
        }
        const geminiData = await geminiResponse.json();
        const generatedText = geminiData?.candidates?.[0]?.content?.parts?.[0]?.text; 
        if (typeof generatedText !== 'string' || generatedText.trim() === '') {
            console.error("Initial Gemini response missing text part:", JSON.stringify(geminiData, null, 2));
            throw new Error('Initial Gemini returned empty or invalid content.');
        }

        // --- Parse Initial Gemini Response ---
        let jsonString = generatedText.trim();
        console.log("Raw Gemini Response:", jsonString.substring(0, 200) + '...');
        
        // Clean the response using our enhanced function
        jsonString = cleanGeminiResponse(jsonString);
        console.log("Cleaned Gemini Response:", jsonString.substring(0, 200) + '...');
        
        try {
            // Try to parse the JSON
            let parsedRecommendations;
            try {
                parsedRecommendations = JSON.parse(jsonString);
            } catch (parseError) {
                console.error("Initial JSON parse failed:", parseError);
                
                // Additional fallback: Look for recommendations array pattern
                const recommendationsMatch = jsonString.match(/"recommendations"\s*:\s*(\[[\s\S]*?\])/);
                if (recommendationsMatch && recommendationsMatch[1]) {
                    try {
                        console.log("Attempting to parse recommendations array directly");
                        const recsArray = JSON.parse(recommendationsMatch[1]);
                        parsedRecommendations = { recommendations: recsArray };
                        console.log("Direct recommendations array parsing successful");
                    } catch (arrayParseError) {
                        console.error("Failed to parse recommendations array directly:", arrayParseError);
                        throw parseError; // Throw the original error
                    }
                } else {
                    throw parseError; // No pattern found, throw the original error
                }
            }
            
            // Validate the parsed result
            if (!parsedRecommendations || !Array.isArray(parsedRecommendations.recommendations)) {
                throw new Error("Parsed JSON does not contain a 'recommendations' array.");
            }
            
            initialGeminiOutput = parsedRecommendations.recommendations;
            console.log("Initial Gemini generation successful.");
            
            // Store in finalResults in case competition fails
            finalResults['gemini'] = initialGeminiOutput;
        } catch (parseError: any) {
            console.error("Failed to parse JSON from initial Gemini:", jsonString, "Error:", parseError);
            throw new Error(`Failed to parse recommendations JSON from initial Gemini: ${parseError.message}`);
        }

        // --- Model Competition Toggle Logic ---
        if (!useModelCompetition) {
            // Model Competition is DISABLED: Use only initial Gemini results
            console.log("Model Competition workflow is DISABLED. Skipping GPT and final Gemini steps.");
            finalResults['gemini'] = initialGeminiOutput;
            
            // Only return early if we're not running other models
            if (!shouldRunOpenAI && !shouldRunClaude) {
                return new NextResponse(
                    JSON.stringify({ results: finalResults, errors: finalErrors }),
                    { status: 200, headers: { 'Content-Type': 'application/json' } }
                );
            }
        }
        // --- STEP 2: Pass to GPT-4.1 for improvement ---
        if (initialGeminiOutput.length > 0 && OPENAI_API_KEY) {
            console.log("STEP 2: Passing Gemini output to GPT-4.1 for improvement...");
            try {
                // Create a complete prompt that includes both the original client & competitor data and Gemini's outputs
                const fullClientInfo = groundedClientInfoCommon;
                const fullCompetitorData = competitorAnalysisData;
                
                const gptChallengePrompt = `
# Client Information
${fullClientInfo}

# Competitor Analysis
${JSON.stringify(fullCompetitorData, null, 2)}

# Original Recommendations from Gemini
Below are recommendations generated by Gemini 2.5. I need you to significantly improve these ideas using the client and competitor information above.

${JSON.stringify(initialGeminiOutput, null, 2)}

# Your Challenge
Create even better marketing recommendations based on the client information and competitor analysis.

Please enhance these recommendations by:
1. Making the concepts more creative, distinctive and strategic
2. Strengthening the tie to market research and competitor analysis
3. Improving the copywriting to be more compelling and impactful
4. Adding more specific statistics, numbers or concrete details where relevant

Maintain the same overall structure but make each idea significantly better. Return the improved version in exactly the same JSON format with the same number of recommendations.

Your response should be valid, parseable JSON with a "recommendations" array, matching the exact original structure.`;
                
                console.log("--- START GPT CHALLENGE PROMPT ---");
                console.log(gptChallengePrompt);
                console.log("--- END GPT CHALLENGE PROMPT ---");

                // Call OpenAI API with the challenge prompt
                const openaiUrl = "https://api.openai.com/v1/chat/completions";
                const openaiPayload = {
                    model: "gpt-4.1-mini",
                    messages: [{ role: "user", content: gptChallengePrompt }],
                    response_format: { type: "json_object" },
                    temperature: 1.0
                };

                const openaiResponse = await fetch(openaiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${OPENAI_API_KEY}`
                    },
                    body: JSON.stringify(openaiPayload)
                });

                if (!openaiResponse.ok) {
                    const errorBody = await openaiResponse.json().catch(() => ({ error: { message: 'Failed to parse error response' } }));
                    const errorMessage = errorBody?.error?.message || `GPT API request failed: ${openaiResponse.status} - ${openaiResponse.statusText}`;
                    console.error('GPT API error response:', errorBody);
                    throw new Error(errorMessage);
                }

                const openaiData = await openaiResponse.json();
                const gptGeneratedText = openaiData?.choices?.[0]?.message?.content;

                console.log("Raw text received from GPT:", gptGeneratedText ? gptGeneratedText.substring(0, 100) + "..." : "<empty>");

                if (typeof gptGeneratedText !== 'string' || gptGeneratedText.trim() === '') {
                    console.error("GPT response missing content:", JSON.stringify(openaiData, null, 2));
                    throw new Error('GPT returned empty or invalid content.');
                }

                // Parse GPT Response
                try {
                    const parsedGptOutput = JSON.parse(gptGeneratedText.trim());
                    if (!parsedGptOutput || !Array.isArray(parsedGptOutput.recommendations)) {
                        throw new Error("Parsed JSON from GPT does not contain a 'recommendations' array.");
                    }
                    gptImprovedOutput = parsedGptOutput.recommendations;
                    console.log("GPT improvement successful.");
                    
                    // Update finalResults with GPT's improved output
                    finalResults['openai'] = gptImprovedOutput;
                } catch (parseError: any) {
                    console.error("Failed to parse JSON from GPT:", gptGeneratedText, "Error:", parseError);
                    throw new Error(`Failed to parse recommendations JSON from GPT: ${parseError.message}`);
                }

                // --- STEP 3: Send back to Gemini for final improvement ---
                if (gptImprovedOutput.length > 0) {
                    console.log("STEP 3: Sending GPT's improved output back to Gemini for final pass...");
                    
                    try {
                        // Create a complete prompt for Gemini that includes both client & competitor data and GPT's improvements
                        const fullClientInfo = groundedClientInfoCommon;
                        const fullCompetitorData = competitorAnalysisData;
                        
                        const geminiCompetitivePrompt = `
# Client Information
${fullClientInfo}

# Competitor Analysis
${JSON.stringify(fullCompetitorData, null, 2)}

# GPT's Recommendations
Below are recommendations improved by GPT-4.1. I need you to create even better recommendations using ALL the information above do you let the GPT win this ??.

${JSON.stringify(gptImprovedOutput, null, 2)}

# Your Challenge: Deep Chain of Thought Process
Create the most impressive, market-leading recommendations possible. Use an advanced Chain of Thought process where you'll deeply consider multiple alternatives before finalizing your output.

## Step 1: Initial Analysis & Research (think internally)
- Critically analyze each of GPT's recommendations and identify weaknesses
- Identify specific research questions that would dramatically improve each recommendation
- Use Google Search to find ANY relevant information that could enhance each recommendation:
  * Marketing case studies and success stories from similar industries
  * Books, academic research, and expert insights on marketing psychology
  * Statistics, facts, and data points that support the recommendations
  * Current Thai market trends and cultural insights
  * Competitor campaigns and strategies from global markets that could be adapted
  * Consumer behavior patterns and psychological principles
- Think deeply about how each piece of information could transform the recommendations

## Step 2: Generate Knowledge-Enhanced Alternatives (think internally)
- For each recommendation, generate 3-4 significantly different creative approaches by:
  * Searching for specific marketing approaches that worked well in similar contexts
  * Finding unique cultural insights specific to Thailand that could make ideas more resonant
  * Researching psychological principles that could enhance persuasiveness
  * Examining successful global campaigns that could be adapted to Thai context
- Deliberately search for diverse, contradictory perspectives to challenge your thinking
- Consider genuinely radical alternatives that break industry conventions 
- Synthesize insights from books, research papers, and expert opinions into your alternatives
- Look for specific data points and statistics that could make each alternative more compelling

## Step 3: Critical Evaluation with Research (think internally)
- Use Google Search to verify key facts and claims in each alternative
- Evaluate each alternative against specific criteria, using search to find evidence:
  - How well it addresses competitive gaps (search for competitor weaknesses)
  - How distinctive it is (search for similar existing campaigns)
  - How actionable and measurable it is (search for relevant KPIs and metrics)
  - How culturally relevant to Thailand it is (search for cultural norms and preferences)
  - How well it leverages current market trends (search for latest industry movements)

## Step 4: Final Selection and Thai Optimization (think internally)
- Select the strongest evidence-backed version of each recommendation
- Perform targeted searches to find specific Thai statistics, cultural references, and local examples
- Search for Thai idioms, expressions, and cultural touchpoints to make copywriting authentic
- Ensure all Thai language elements are grammatically correct and culturally appropriate
- Double-check all factual claims with additional searches
- For each recommendation, find at least one concrete data point, case study, or expert opinion to strengthen it

After completing this internal Chain of Thought process, provide ONLY your final recommendations in valid, parseable JSON with a "recommendations" array, matching the exact original structure. 

Remember: The actual CoT thinking should be internal - your final response must be clean JSON only.`;
                        
                        console.log("--- START GEMINI COMPETITIVE PROMPT ---");
                        console.log(geminiCompetitivePrompt);
                        console.log("--- END GEMINI COMPETITIVE PROMPT ---");

                        // Step 3A: First do research with Google Search tool (without JSON response format)
                        console.log("Step 3A: Performing Google Search research first...");
                        
                        // Create a research-focused prompt that explicitly asks for search
                        const researchPrompt = `
# Research Request

I need you to research information that will help create marketing recommendations for the following client:

${fullClientInfo}

# Research Questions
1. What are the latest market trends related to this client's industry in Thailand?
2. What strategies have been successful for similar businesses?
3. What cultural elements would resonate with Thai audiences for this product/service?
4. What specific statistics or data points could strengthen marketing recommendations?
5. What unique approaches would help this client stand out from competitors?
6. What success case studies could help this client stand out from competitors?

Please provide detailed research findings using Google Search. Focus on finding concrete information, examples, and data that could be used to create exceptional marketing recommendations. `;
                        
                        const researchResponse = await fetch(geminiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                contents: [{ parts: [{ text: researchPrompt }] }],
                                tools: [{ "google_search": {} }], // Enable Google Search for research phase
                                generationConfig: { temperature: 1.0 }
                            })
                        });

                        if (!researchResponse.ok) {
                            const errorText = await researchResponse.text();
                            console.warn(`Research phase request failed: ${researchResponse.status} - ${errorText}`);
                            console.log("Proceeding with final recommendations without research phase.");
                            // Continue to next step even if research fails
                        }
                        
                        // Extract research results if available
                        let researchResults = "";
                        try {
                            const researchData = await researchResponse.json();
                            researchResults = researchData?.candidates?.[0]?.content?.parts?.[0]?.text || "";
                            console.log("Research completed successfully.");
                        } catch (e) {
                            console.warn("Failed to process research results:", e);
                            // Continue even if we couldn't extract research results
                        }
                        
                        // Step 3B: Now generate final recommendations with JSON format (no Google Search tool)
                        console.log("Step 3B: Generating final recommendations with research input...");
                        
                        // Add research results to the final prompt
                        const finalPromptWithResearch = `
${geminiCompetitivePrompt}

# Research Findings
Use these research findings to enhance your recommendations:
And Ideas Should Respresent our Client and Key Strength, Social Proof Base on Fact and Statistic
${researchResults}

# Response Format Requirements
You MUST return ONLY a valid JSON object with this exact structure:
{
  "recommendations": [
    {
      "title": "First Recommendation Title",
      "description": "Detailed description...",
      "impact": "High",
      "category": "Category name",
      "copywriting": { "headline": "...", "body": "...", "cta": "..." }
    },
    // 8 more recommendations for a total of 9
  ]
}

Do NOT include any text outside the JSON. No markdown formatting, no explanations, just the JSON object.`;
                        
                        // Make the final call with JSON response format but WITHOUT tools
                        const finalGeminiResponse = await fetch(geminiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                contents: [{ parts: [{ text: finalPromptWithResearch }] }],
                                // No tools in this request
                                generationConfig: { 
                                    temperature: 1.0,
                                    response_mime_type: "application/json"
                                }
                            })
                        });

                        if (!finalGeminiResponse.ok) {
                            const errorText = await finalGeminiResponse.text();
                            throw new Error(`Final Gemini API request failed: ${finalGeminiResponse.status} - ${errorText}`);
                        }

                        const finalGeminiData = await finalGeminiResponse.json();
                        const finalGeminiText = finalGeminiData?.candidates?.[0]?.content?.parts?.[0]?.text;

                        if (typeof finalGeminiText !== 'string' || finalGeminiText.trim() === '') {
                            console.error("Final Gemini response missing text part:", JSON.stringify(finalGeminiData, null, 2));
                            throw new Error('Final Gemini returned empty or invalid content.');
                        }

                        // Parse Final Gemini Response
                        try {
                            // Clean up the response text - attempt to extract JSON if it's wrapped in other text
                            let cleanedText = finalGeminiText.trim();
                            
                            // Try to find JSON content if wrapped in other text
                            const jsonStartMatch = cleanedText.match(/\{\s*["']recommendations["']\s*:/i);
                            const jsonStart = jsonStartMatch ? jsonStartMatch.index || 0 : -1;
                            if (jsonStart >= 0) {
                                // Extract what looks like the JSON portion
                                let openBraces = 0;
                                let endIndex = jsonStart;
                                let foundClosingBrace = false;
                                
                                for (let i = jsonStart; i < cleanedText.length; i++) {
                                    const char = cleanedText[i];
                                    if (char === '{') openBraces++;
                                    if (char === '}') openBraces--;
                                    if (openBraces === 0) {
                                        endIndex = i + 1;
                                        foundClosingBrace = true;
                                        break;
                                    }
                                }
                                
                                if (foundClosingBrace) {
                                    cleanedText = cleanedText.substring(jsonStart, endIndex);
                                    console.log("Extracted JSON content from response:", cleanedText);
                                }
                            }
                            
                            // Try parsing the JSON
                            const parsedFinalOutput = JSON.parse(cleanedText);
                            
                            // Check for recommendations array
                            if (!parsedFinalOutput) {
                                throw new Error("Parsed JSON from final Gemini is empty or null");
                            }
                            
                            // If we have directly an array, assume it's the recommendations
                            if (Array.isArray(parsedFinalOutput)) {
                                console.log("Gemini returned direct array, using as recommendations");
                                finalGeminiOutput = parsedFinalOutput;
                            } 
                            // If we have a recommendations array property
                            else if (Array.isArray(parsedFinalOutput.recommendations)) {
                                finalGeminiOutput = parsedFinalOutput.recommendations;
                            } 
                            // If we have something else that contains objects, try to use that
                            else {
                                // Look for any property that is an array of objects
                                const arrayProps = Object.keys(parsedFinalOutput)
                                    .filter(key => Array.isArray(parsedFinalOutput[key]) && 
                                            parsedFinalOutput[key].length > 0 && 
                                            typeof parsedFinalOutput[key][0] === 'object');
                                
                                if (arrayProps.length > 0) {
                                    // Use the first array property found
                                    const arrayProp = arrayProps[0];
                                    console.log(`Using '${arrayProp}' array property as fallback for recommendations`);
                                    finalGeminiOutput = parsedFinalOutput[arrayProp];
                                } else {
                                    throw new Error("Could not find any array property that could contain recommendations");
                                }
                            }
                            
                            console.log("Final Gemini improvement successful.");
                            
                            // Update finalResults with Gemini's final improved output
                            finalResults['gemini'] = finalGeminiOutput;
                            
                            // Set the model competition flag to true
                            finalResults['_metadata'] = {
                                modelCompetition: true,
                                steps: ['gemini_initial', 'openai_improvement', 'gemini_final']
                            };
                            
                        } catch (parseError: any) {
                            console.error("Failed to parse JSON from final Gemini:", finalGeminiText, "Error:", parseError);
                            // Use the GPT results as fallback instead of throwing
                            console.log("Using GPT improved results as fallback due to Gemini JSON parsing error.");
                            finalResults['gemini'] = gptImprovedOutput;
                            finalResults['_metadata'] = {
                                modelCompetition: true, 
                                steps: ['gemini_initial', 'openai_improvement']
                            };
                        }
                    } catch (finalGeminiError: any) {
                        console.error("Error during final Gemini improvement:", finalGeminiError);
                        // Keep the GPT improved results if final Gemini fails
                        console.log("Using GPT improved results since final Gemini failed.");
                    }
                }
            } catch (gptError: any) {
                console.error("Error during GPT improvement step:", gptError);
                // Keep initial Gemini results if GPT improvement fails
                console.log("Using initial Gemini results since GPT improvement failed."); 
            }
        }
    } catch (initialGeminiError: any) {
        console.error("Error during initial Gemini generation:", initialGeminiError);
        finalErrors['gemini'] = initialGeminiError.message || "An unknown error occurred during Gemini generation.";
        finalResults['gemini'] = null; // Ensure no stale results
    }
    } // Close shouldRunGemini if block
    
    // Skip individual model generation if we did the competition workflow
    if (finalResults['_metadata']?.modelCompetition) {
        console.log("Model competition workflow completed successfully.");
    } else {
        // Fall back to individual model generation if competition workflow failed
        console.log("Model competition workflow incomplete or failed, falling back to individual generation.");
        
        // --- Individual Gemini Generation if not already done ---
        if (requestedModels.includes('gemini') && !finalResults['gemini']) {
            // Gemini generation code would go here (removed for brevity as it's now handled above)
        }
    }

    // --- OpenAI Generation (Conditional) ---
    if (shouldRunOpenAI) {
        console.log("Starting OpenAI generation...");
        try {
            // --- Prepare OpenAI Prompt (using common builder, no grounding needed here) ---
            const finalOpenAIPrompt = await buildFinalUserPrompt(
              analysisRunData.clientName || 'Unknown Client',  // clientName (string)
              analysisRunData.market || 'Unknown Market',      // market (string)
              analysisRunData.productFocus || null            // productFocus (string | null)
            //   typeof userBrief === 'string' ? userBrief : '',  // userBrief (string)
            //   typeof groundedClientInfoCommon === 'string' ? groundedClientInfoCommon : '', // groundedInfo (string)
            //   typeof bookSummaryContent === 'string' ? bookSummaryContent : '', // bookSummaryContent (string)
            //   (includeCompetitorAnalysis && typeof competitorAnalysisData === 'string') ? competitorAnalysisData : '', // competitorAnalysisText (string)
            //   typeof taskSectionParam === 'string' ? taskSectionParam : null, // taskSectionParam (string | null)
            //   typeof detailsSectionParam === 'string' ? detailsSectionParam : null, // detailsSectionParam (string | null)
            //   typeof analysisRunData.ad_account_id === 'string' ? analysisRunData.ad_account_id : undefined // adAccountId (string | undefined)
            );

            // --- Log OpenAI Prompt ---
            console.log("--- START FINAL OPENAI PROMPT ---");
            console.log(finalOpenAIPrompt);
            console.log("--- END FINAL OPENAI PROMPT ---");

            // --- Call OpenAI API ---
            console.log("Sending request to OpenAI API...");
            const openaiUrl = "https://api.openai.com/v1/chat/completions";
            const openaiPayload = {
                model: "gpt-4.1", // Using a current model that exists
                messages: [
                    // Optional System prompt can be added here if desired for OpenAI
                    // { role: "system", content: systemPrompt }, 
                    { role: "user", content: finalOpenAIPrompt }
                ],
                response_format: { type: "json_object" }, // Request JSON output
                temperature: 1.0 // Adjust temperature if needed
            };

            const openaiResponse = await fetch(openaiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${OPENAI_API_KEY}`
                },
                body: JSON.stringify(openaiPayload)
            });

            if (!openaiResponse.ok) {
                const errorBody = await openaiResponse.json().catch(() => ({ error: { message: 'Failed to parse error response' } }));
                const errorMessage = errorBody?.error?.message || `OpenAI API request failed: ${openaiResponse.status} - ${openaiResponse.statusText}`;
                console.error('OpenAI API error response:', errorBody);
                throw new Error(errorMessage);
            }

            const openaiData = await openaiResponse.json();
            const generatedText = openaiData?.choices?.[0]?.message?.content;

            console.log("Raw text received from OpenAI:", generatedText);

            if (typeof generatedText !== 'string' || generatedText.trim() === '') {
                 console.error("OpenAI response missing content:", JSON.stringify(openaiData, null, 2));
                throw new Error('OpenAI returned empty or invalid content.');
            }

            // --- Parse OpenAI Response ---
            let parsedRecommendations: GeminiRecommendationOutput;
            let jsonString = generatedText.trim(); // Assume direct JSON due to response_format
            try {
                parsedRecommendations = JSON.parse(jsonString);
                if (!parsedRecommendations || !Array.isArray(parsedRecommendations.recommendations)) {
                    throw new Error("Parsed JSON does not contain a 'recommendations' array.");
                }
                finalResults['openai'] = parsedRecommendations.recommendations; // Store successful result
                console.log("OpenAI generation successful.");
            } catch (parseError: any) {
                console.error("Failed to parse JSON from OpenAI:", jsonString, "Error:", parseError);
                throw new Error(`Failed to parse recommendations JSON from OpenAI: ${parseError.message}`);
            }

        } catch (openaiError: any) {
            console.error("Error during OpenAI generation process:", openaiError);
            finalErrors['openai'] = openaiError.message || "An unknown error occurred during OpenAI generation.";
            finalResults['openai'] = null; // Ensure no stale results
        }
    }

    // --- Claude Generation (Conditional) ---
    if (shouldRunClaude) {
        console.log("Starting Claude generation...");
        try {
            // --- Prepare Claude Prompt (using common builder, no grounding needed here) ---
            const finalClaudePrompt = await buildFinalUserPrompt(
              analysisRunData.clientName || 'Unknown Client',  // clientName (string)
              analysisRunData.market || 'Unknown Market',      // market (string)
              analysisRunData.productFocus || null,            // productFocus (string | null)
            //   typeof userBrief === 'string' ? userBrief : '',  // userBrief (string)
            //   typeof groundedClientInfoCommon === 'string' ? groundedClientInfoCommon : '', // groundedInfo (string)
            //   typeof bookSummaryContent === 'string' ? bookSummaryContent : '', // bookSummaryContent (string)
            //   (includeCompetitorAnalysis && typeof competitorAnalysisData === 'string') ? competitorAnalysisData : '', // competitorAnalysisText (string)
            //   typeof taskSectionParam === 'string' ? taskSectionParam : null, // taskSectionParam (string | null)
            //   typeof detailsSectionParam === 'string' ? detailsSectionParam : null, // detailsSectionParam (string | null)
            //   typeof analysisRunData.ad_account_id === 'string' ? analysisRunData.ad_account_id : undefined // adAccountId (string | undefined)
            );
            
            // Use the predefined systemPrompt
            const systemPromptClaude = "You are an AI assistant tasked with generating creative marketing recommendations. Your response MUST be a single, valid JSON object and nothing else. Do not include any text before or after the JSON object. All text content within the JSON object MUST be in THAI language.";

            // --- Log Claude Prompt ---
            console.log("--- START FINAL CLAUDE PROMPT ---");
            console.log("System Prompt:", systemPromptClaude);
            console.log("User Prompt:", finalClaudePrompt);
            console.log("--- END FINAL CLAUDE PROMPT ---");

            // --- Call Claude API ---
            console.log("Sending request to Anthropic API...");
            const claudeUrl = "https://api.anthropic.com/v1/messages";
            const claudePayload = {
                model: "claude-sonnet-4-20250514", // Updated to a current model name
                max_tokens: 64000,
                system: systemPromptClaude, // Use the specific system prompt
                messages: [
                    { role: "user" as const, content: finalClaudePrompt } // Use the common user prompt
                ],
                temperature: 1.0 // Adjusted temperature
            };

            const claudeResponse = await fetch(claudeUrl, {
                method: 'POST',
                headers: {
                    'x-api-key': ANTHROPIC_API_KEY!,
                    'anthropic-version': '2023-06-01',
                    'content-type': 'application/json'
                },
                body: JSON.stringify(claudePayload)
            });

            if (!claudeResponse.ok) {
                const errorText = await claudeResponse.text();
                let errorMessage = `Anthropic API request failed: ${claudeResponse.status} - ${claudeResponse.statusText}`;
                try {
                    const errorBody = JSON.parse(errorText);
                    errorMessage = errorBody?.error?.message || errorMessage;
                    console.error('Anthropic API error response (parsed):', errorBody);
                } catch {
                     console.error('Anthropic API error response (text):', errorText);
                     errorMessage += ` - ${errorText}`
                }
                throw new Error(errorMessage);
            }

            const claudeData = await claudeResponse.json();
            const generatedText = claudeData?.content?.[0]?.text;

            console.log("Raw text received from Claude:", generatedText);

            if (typeof generatedText !== 'string' || generatedText.trim() === '') {
                console.error('Claude response missing text content:', JSON.stringify(claudeData, null, 2));
                throw new Error('Claude returned empty or invalid content in the expected structure.');
            }

            // --- Parse Claude Response ---
            let parsedRecommendations: GeminiRecommendationOutput;
            let jsonString = '';
            try {
                // Attempt to extract JSON even if wrapped
                let potentiallyCleanedText = generatedText.trim().replace(/^```json\n/, '').replace(/\s*```$/, '');
                const startIndex = potentiallyCleanedText.indexOf('{');
                const endIndex = potentiallyCleanedText.lastIndexOf('}');
                if (startIndex === -1 || endIndex === -1 || endIndex < startIndex) {
                    console.error("Invalid JSON structure found in Claude text:", potentiallyCleanedText)
                    throw new Error('AI response did not contain a valid JSON object structure.');
                }
                jsonString = potentiallyCleanedText.substring(startIndex, endIndex + 1);
                parsedRecommendations = JSON.parse(jsonString);
                if (!parsedRecommendations || !Array.isArray(parsedRecommendations.recommendations)) {
                     console.error("Parsed JSON missing 'recommendations' array:", parsedRecommendations);
                    throw new Error("Parsed JSON does not contain a 'recommendations' array.");
                }
                finalResults['claude'] = parsedRecommendations.recommendations; // Store successful result
                console.log("Claude generation successful.");
            } catch (parseError: any) {
                console.error("Failed to parse JSON from Claude:", jsonString, "Error:", parseError);
                throw new Error(`Failed to parse recommendations JSON from Claude: ${parseError.message}`);
            }

        } catch (claudeError: any) {
            console.error("Error during Claude generation process:", claudeError);
            finalErrors['claude'] = claudeError.message || "An unknown error occurred during Claude generation.";
            finalResults['claude'] = null; // Ensure no stale results
        }
    }

    // --- Return Combined Results ---
    console.log("Final results being returned:", JSON.stringify(finalResults));
    console.log("Final errors being returned:", JSON.stringify(finalErrors));
    return NextResponse.json({ results: finalResults, errors: finalErrors });

  } catch (error) {
    // Catch errors from initial data fetching (Supabase, etc.)
    console.error(`Unhandled error in GET /api/generate-recommendations for runId ${runId}:`, error);
    let errorMessage = 'Failed to generate recommendations due to a server error.';
    if (error instanceof Error) {
        errorMessage = error.message;
    }
    // Return a general error structure - frontend expects { results: {}, errors: {} }
    return new NextResponse(
        JSON.stringify({ results: {}, errors: { general: errorMessage } }),
        { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  } finally {
    // Optional: Disconnect Supabase client if needed
  }
} 

// Define types for the POST response
type ModelResults = Record<string, any[]>;
type ModelErrorState = Record<string, string | null>;

export async function POST(request: NextRequest) {
    try {
        // Parse query parameters
        const { searchParams } = new URL(request.url);
        const runId = searchParams.get('runId');
        const models = searchParams.get('models')?.split(',') || [];
        const brief = searchParams.get('brief') || '';
        const taskSection = searchParams.get('taskSection') || '';
        const includeCompetitorAnalysis = searchParams.get('includeCompetitorAnalysis') !== 'false';

        console.log(`GET /api/generate-recommendations for runId: ${runId}, Models: ${models.join(', ')}, Include Competitor Analysis: ${includeCompetitorAnalysis}`);
        
        let competitorAnalysis = "";
        if (includeCompetitorAnalysis) {
            const clientName = searchParams.get('clientName') || '';
            const productFocus = searchParams.get('productFocus') || '';
            
            if (clientName && productFocus) {
                try {
                    const { data: allAnalysisData, error } = await supabaseAdmin
                        .from('competitor_analysis')
                        .select('analysis_data, client_name, product_focus, created_at')
                        .eq('client_name', clientName.trim())
                        .eq('product_focus', productFocus.trim())
                        .order('created_at', { ascending: false })
                        .limit(1);
                    
                    if (error) throw error;
                    if (allAnalysisData && allAnalysisData.length > 0) {
                        competitorAnalysis = JSON.stringify(allAnalysisData[0].analysis_data, null, 2);
                        console.log("Fetched competitor analysis data");
                    }
                } catch (error) {
                    console.error("Error fetching competitor analysis:", error);
                    // Continue without competitor analysis if there's an error
                }
            }
        }

        // Validate required parameters
        if (!runId) {
            return new NextResponse(
                JSON.stringify({ error: 'Missing required parameter: runId' }),
                { status: 400, headers: { 'Content-Type': 'application/json' } }
            );
        }

        if (!models || models.length === 0) {
            return new NextResponse(
                JSON.stringify({ error: 'Missing required parameter: models' }),
                { status: 400, headers: { 'Content-Type': 'application/json' } }
            );
        }

        // Check API keys
        const GEMINI_API_KEY = process.env.GEMINI_API_KEY;
        const OPENAI_API_KEY = process.env.OPENAI_API_KEY;
        const ANTHROPIC_API_KEY = process.env.ANTHROPIC_API_KEY;

        if (models.includes('gemini') && !GEMINI_API_KEY) {
            console.error("GEMINI_API_KEY is not set.");
            return new NextResponse(JSON.stringify({ error: 'Server configuration error: Missing Gemini API key.' }), { status: 500 });
        }
        if (models.includes('openai') && !OPENAI_API_KEY) {
            console.error("OPENAI_API_KEY is not set.");
            return new NextResponse(JSON.stringify({ error: 'Server configuration error: Missing OpenAI API key.' }), { status: 500 });
        }
        if (models.includes('claude') && !ANTHROPIC_API_KEY) {
            console.error("ANTHROPIC_API_KEY is not set.");
            return new NextResponse(JSON.stringify({ error: 'Server configuration error: Missing Anthropic API key.' }), { status: 500 });
        }

        // --- Initialize result holders ---
        const results: Record<string, any> = {};
        const errors: ModelErrorState = {};
        let groundedClientInfo = ''; // Initialize groundedClientInfo variable

        // Define the function to build the final user prompt (similar to GET handler)
        const buildFinalUserPrompt = (groundedInfo: string, competitorAnalysisText: string = '') => {
            // Fetch client info from query params
            const clientInfo = {
                clientName: searchParams.get('clientName') || "Client",
                market: searchParams.get('market') || "Market",
                productFocus: searchParams.get('productFocus') || "Products/Services"
            };

            const groundedSection = groundedInfo ? `
---
*(This section provides recent context about ${clientInfo.clientName}. Consider these details alongside the core client information to ensure recommendations are timely and relevant. Use specific points from here where they offer a clear advantage or fresh angle.)*
` : '';

            const userBriefSection = brief ? `
**Additional User Brief/Context:**
${brief}
` : '';

            // Define default prompt sections
            const defaultTaskText = `1. Spark and detail 7-10 fresh, distinctive, and engaging creative ideas for ${clientInfo.clientName}, specifically focusing on concepts highly suitable for Facebook Ad campaigns. Focus on concepts that can present the client's specific ${clientInfo.productFocus} from new perspectives that spark curiosity, drive engagement, or create a memorable impression within the ${clientInfo.market} on social media. Ideas should build upon the client's strengths and available insights.
            2. Focus on Actionable Creativity for Facebook: Ensure each recommendation translates into tangible marketing ideas easily adaptable into compelling Facebook Ad formats (e.g., single image/video, carousel, stories, reels). Include potential ad angles, visual directions, and calls-to-action. Prioritize ideas that are visually arresting, memorable, shareable, emotionally resonant, and push creative boundaries for this specific client on Facebook.
            3. Informed by Context: Where available, let the \`groundedClientInfo\` and \`bookSummarySection\` inform the relevance, timeliness, or strategic angle of your ideas, but the core inspiration should stem from the client's fundamental product/service and market position. Use grounding to verify trends or competitor actions if needed.
            4. For EACH recommendation, provide the Creative Execution Details below, specifically tailored for a Facebook Ad context. Generate specific, compelling content for each field IN THAI LANGUAGE, imagining how the core idea translates into ad components (e.g., Headline, Ad Copy, Visual Description, Call-to-Action).
            5. Populate the corresponding fields in the final JSON object. Ensure all text output is original for this request
            6. Ideas to include but not limited to: why the solutions from ${clientInfo.clientName} are different than what is being offered in the market currently. Talk about the differentiation of the product if and when it makes the client's product or service more appealing. 
            7. Competitor Analysis is important please use it to make a strategic idea.`;
            
            const defaultDetailsText = `a.  **\`content_pillar\`:** กำหนดธีมเนื้อหาหลักหรือหมวดหมู่ **(ภาษาไทย)** (เช่น "เคล็ดลับฮาวทู", "เบื้องหลังการทำงาน", "เรื่องราวความสำเร็จลูกค้า", "การหักล้างความเชื่อผิดๆ", "ไลฟ์สไตล์และการใช้งาน", "ปัญหาและการแก้ไข").
                                b.  **\`product_focus\`:** ระบุ ${clientInfo.productFocus || 'ผลิตภัณฑ์/บริการ'} ที่ต้องการเน้น **(ภาษาไทย)**.
                                c.  **\`concept_idea\`:** สรุปแนวคิดสร้างสรรค์หลัก (1-2 ประโยค) สำหรับการนำเสนอไอเดียนี้ **(ภาษาไทย)**.
                                d.  **\`copywriting\`:** สร้างสรรค์องค์ประกอบข้อความโฆษณาเบื้องต้น **(ภาษาไทย)**:
                                    *   **\`headline\`:** พาดหัวที่ดึงดูดความสนใจ **(ภาษาไทย)**.
                                    *   **\`sub_headline_1\`:** พาดหัวรองที่ขยายความหรือเน้นประโยชน์ **(ภาษาไทย)**.
                                    *   **\`sub_headline_2\`:** พาดหัวรองที่สอง (ถ้ามี) เพื่อเพิ่มบริบทหรือความเร่งด่วน **(ภาษาไทย)** (ใช้ \`null\` หากไม่ต้องการ).
                                    *   **\`bullets\`:** รายการจุดเด่น 2-4 ข้อที่เน้นประโยชน์หลัก, ฟีเจอร์ หรือเหตุผลที่น่าเชื่อถือ **(ภาษาไทย)**.
                                    *   **\`cta\`:** ข้อความเรียกร้องให้ดำเนินการ (Call To Action) ที่ชัดเจน **(ภาษาไทย)** (เช่น "เรียนรู้เพิ่มเติม", "ซื้อเลย", "ดูเดโม", "เข้าร่วม Waiting List", "ดาวน์โหลดคู่มือ").`;

            const taskSectionContent = taskSection || defaultTaskText;
            // Always use the default details section
            const detailsSectionContent = defaultDetailsText;

            return `

You are an expert marketing agencies strategist and ideas manager, highly skilled in psychological persuasion and proven advertising methods. Your task is to create compelling, highly persuasive advertising ideas strategies copy designed to maximize customer attraction, engagement, and conversions.
When creating the ideas, you can apply relevant psychological principles of persuasion and advertising techniques, particularly those outlined in Drew Eric Whitman’s book “Cashvertising”— including but not limited to the Life-Force 8 (LF8), the Nine Learned (Secondary) Wants, Ego Morphing, Transfer of Credibility, Bandwagon Effect, Fear Factor, Means-End Chain, and Robert Cialdini’s Six Weapons of Influence (Comparison, Liking, Authority, Reciprocation, Commitment/Consistency, Scarcity)—but only where these principles naturally apply and genuinely enhance effectiveness.
Critically, do not limit yourself exclusively to the techniques or command i just give youmentioned; incorporate any additional creative strategies, psychological insights, and proven persuasion techniques that you consider effective or innovative, based on your broad expertise.

**Client Information:**
*   Name: ${clientInfo.clientName}
*   Market: ${clientInfo.market}
*   Product Focus: ${clientInfo.productFocus}
${userBriefSection}
${groundedSection}

${includeCompetitorAnalysis ? `**Competitor Landscape Summary:**
${competitorAnalysisText}
*(Analyze the competitor summary, recent client info, and optional book context...)*
` : ''}

**Task:**
${taskSectionContent} use ${groundedInfo} to generate recommendations ideas that respresent จุดเด่น, ผลิตภัณฑ์เด่น, โปรโมชั่น แคมเปญล่าสุด หรือ กิจกรรมล่าสุด หรือ ข้อมูลสำคัญต่างๆ 
**Creative Execution Details (Per Recommendation - Populate these fields IN THAI for the JSON):**
${detailsSectionContent}

Ensure your copy aligns with modern, high-quality advertising standards and is tailored to effectively resonate with the specific target audience provided.

**Output Format Requirements:**
*   Return ONLY a single, valid JSON object. No introductory text, explanations, or markdown formatting (like \`\`\`json\`\`).
*   The JSON object MUST strictly follow the structure below.
*   **Crucially, the values for \`content_pillar\`, \`product_focus\`, \`concept_idea\`, and all fields within \`copywriting\` (\`headline\`, \`sub_headline_1\`, \`sub_headline_2\`, \`bullets\`, \`cta\`) MUST be generated in THAI LANGUAGE.**
*   \`title\` and \`description\` fields should also be generated in THAI LANGUAGE.
*   Use "High", "Medium", or "Low" for the impact field (bias towards "High").
*   Provide a concise "competitiveGap" string (in THAI LANGUAGE).
*   Include 2-4 relevant and specific keyword strings in the "tags" array (in THAI LANGUAGE).

**Required JSON Structure:**
\`\`\`json
{
  "recommendations": [
    {
      "title": "หัวข้อที่อธิบายว่าไอเดียนี้สื่อถึงอะไร นำเสนออะไร ใช้บริการหรือสินค้าอะไรหรือเน้นย้ำจุดแข็งอะไรของแบรนด์ อธิบายแบบละเอียด (ภาษาไทย)", // Thai - Must be original
      "description": "รายละเอียดแนวคิดสร้างสรรค์ ที่ไม่ซ้ำใคร และมีประสิทธิภาพ (ภาษาไทย)", // Thai - Must be original
      "category": "Campaign", // Keep category identifier standard
      "impact": "High",
      "competitiveGap": "ระบุช่องว่างทางการแข่งขันที่ไอเดียนี้เข้าไปตอบโจทย์ (ภาษาไทย)", // Thai - Must be original
      "tags": ["คำค้น1", "คำค้น2", "รูปแบบเนื้อหา"], // Thai - Must be original
      "content_pillar": "ตัวอย่าง: เคล็ดลับฮาวทู", // Thai - Must be original
      "product_focus": "ระบุ ${clientInfo.productFocus || 'ผลิตภัณฑ์/บริการ'} ที่ระบุใน Input", // Thai - Must be original & specific to input
      "concept_idea": "สรุปแนวคิดสร้างสรรค์หลักสำหรับการนำเสนอไอเดียนี้ (1-2 ประโยค)", // Thai - Must be original
      "copywriting": {
        "headline": "พาดหัวหลักที่ดึงดูดความสนใจ", // Thai - Must be original
        "sub_headline_1": "พาดหัวรองที่ขยายความหรือเน้นประโยชน์", // Thai - Must be original
        "sub_headline_2": "พาดหัวรองที่สอง (ถ้ามี) หรือ null", // Thai - Must be original or null
        "bullets": [
          "จุดเด่นที่ 1", // Thai - Must be original
          "จุดเด่นที่ 2", // Thai - Must be original
          "จุดเด่นที่ 3"  // Thai - Must be original
        ],
        "cta": "ตัวอย่าง: ดูเพิ่มเติม" // Thai - Must be original
      }
    }
    // ... more recommendation objects (7-10 total)
  ]
}
\`\`\`
`;
        };

        try {
            // Build the final prompt with competitor analysis if enabled
            const competitorAnalysisText = includeCompetitorAnalysis ? competitorAnalysis : '';
            // let finalPrompt = buildFinalUserPrompt('', competitorAnalysisText, includeCompetitorAnalysis);
            // console.log(`Final prompt (first 200 chars): ${finalPrompt.substring(0, 200)}...`);
            console.log(`Competitor analysis included: ${includeCompetitorAnalysis}, Length: ${competitorAnalysisText.length}`);
            
            // Remove the placeholder response and continue with the actual implementation
            // ... rest of the existing implementation ...
            
        } catch (error: any) {
            console.error('Error in POST /api/generate-recommendations:', error);
            return new NextResponse(
                JSON.stringify({ 
                    results: {}, 
                    errors: { general: `Server error: ${error.message || 'Unknown error'}` } 
                }),
                { status: 500, headers: { 'Content-Type': 'application/json' } }
            );
        }
    } catch (error: any) {
        console.error('Error parsing request in POST /api/generate-recommendations:', error);
        return new NextResponse(
            JSON.stringify({ 
                results: {}, 
                errors: { general: `Request parsing error: ${error.message || 'Unknown error'}` } 
            }),
            { status: 400, headers: { 'Content-Type': 'application/json' } }
        );
    }
}