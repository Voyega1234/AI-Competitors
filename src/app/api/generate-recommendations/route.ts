import { NextRequest, NextResponse } from 'next/server';
import supabaseAdmin from '@/lib/supabaseClient'; // Import Supabase client
import fs from 'fs/promises'; // Add fs import
import path from 'path'; // Add path import

// TODO: Define the expected structure for a recommendation generated by Gemini
interface GeneratedRecommendation {
    title: string;
    description: string;
    category: string; // e.g., Campaign, Promotion, Content, Feature, Initiative
    impact: string;   // e.g., High, Medium, Low
    competitiveGap?: string | null;
    tags?: string[] | null;
    // --- Add Thai Strategic Analysis Fields ---
    purpose_th: string;       // ๑. รู้เป้าหมาย
    target_audience_th: string; // ๒. รู้คนฟัง/คนใช้
    context_th: string;         // ๓. รู้บริบท
    constraints_th: string;     // ๔. รู้ข้อจำกัด
    competitors_th: string;     // ๕. รู้ว่าใครทำอะไรไปแล้ว
    untapped_potential_th: string; // ๖. รู้ว่าอะไร "ยังไม่มีใครกล้าทำ"
}

// Expected structure from the Gemini JSON response
interface GeminiRecommendationOutput {
    recommendations: GeneratedRecommendation[];
}

// Define the path to the book summaries directory (should match the one in /api/book-summaries)
const booksDirectory = path.join(process.cwd(), 'src', 'app', 'api', 'generate-recommendations', 'books_prompts');

// Helper function to create a concise summary of competitor data
function summarizeCompetitors(competitors: Competitor[]): string {
    if (!competitors || competitors.length === 0) {
        return "No competitor data available.";
    }

    let summary = `Analysis of ${competitors.length} competitors reveals:\n`;

    // --- Basic Service Overview ---
    const allServices = new Set<string>();
    competitors.forEach(c => c.services?.forEach(s => allServices.add(s.toLowerCase())));
    if (allServices.size > 0) {
        summary += `- Common service areas include: ${Array.from(allServices).slice(0, 5).join(', ')}${allServices.size > 5 ? '...' : ''}.\n`;
    }

    // --- Pricing Insights (Example) ---
    const pricingModels = new Set<string>();
    competitors.forEach(c => { if (c.pricing) pricingModels.add(c.pricing); });
    if (pricingModels.size > 0) {
        summary += `- Pricing models observed: ${Array.from(pricingModels).slice(0, 3).join(', ')}.\n`;
    }
    
    // --- Strengths/Weaknesses (Example) ---
    const commonStrengths = new Map<string, number>();
    const commonWeaknesses = new Map<string, number>();
    competitors.forEach(c => {
        c.strengths?.forEach(s => commonStrengths.set(s.toLowerCase(), (commonStrengths.get(s.toLowerCase()) || 0) + 1));
        c.weaknesses?.forEach(w => commonWeaknesses.set(w.toLowerCase(), (commonWeaknesses.get(w.toLowerCase()) || 0) + 1));
    });
    // Helper to get top N items from a map
    const getTopItems = (map: Map<string, number>, topN: number) => Array.from(map.entries())
                                                                          .sort((a, b) => b[1] - a[1])
                                                                          .slice(0, topN)
                                                                          .map(entry => entry[0]);

    const topStrengths = getTopItems(commonStrengths, 2);
    const topWeaknesses = getTopItems(commonWeaknesses, 2);
    if (topStrengths.length > 0) summary += `- Common competitor strengths: ${topStrengths.join(', ')}.\n`;
    if (topWeaknesses.length > 0) summary += `- Common competitor weaknesses: ${topWeaknesses.join(', ')}.\n`;

    // Add more summary points as needed (e.g., target audience, market share hints)

    return summary;
}

// Define a basic Competitor type matching Supabase table structure (adjust if needed)
interface Competitor {
  id: string; // Or number depending on your schema
  analysisRunId: string; // Foreign key
  name?: string | null;
  services?: string[] | null;
  pricing?: string | null;
  strengths?: string[] | null;
  weaknesses?: string[] | null;
  targetAudience?: string | null;
  // Add other fields from your Competitor table
}

// Define AnalysisRun type matching Supabase table structure (adjust if needed)
interface AnalysisRun {
  id: string;
  clientName: string;
  market: string;
  productFocus: string | null;
  // Add other fields from your AnalysisRun table
}

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;
  const runId = searchParams.get('runId');
  const userBrief = searchParams.get('brief');
  const taskSectionParam = searchParams.get('taskSection');
  const detailsSectionParam = searchParams.get('detailsSection');
  const bookFilenamesParam = searchParams.get('bookFilenames'); // NEW: Comma-separated list
  const GEMINI_API_KEY = process.env.NEXT_PUBLIC_GEMINI_API_KEY; // Use server-side key

  console.log(`Attempting to handle GET /api/generate-recommendations for runId: ${runId}`);

  if (!runId) {
    return new NextResponse(
      JSON.stringify({ error: 'runId query parameter is required' }),
      { status: 400, headers: { 'Content-Type': 'application/json' } }
    );
  }
  if (!GEMINI_API_KEY) {
      console.error("GEMINI_API_KEY is not set in environment variables.");
      return new NextResponse(JSON.stringify({ error: 'Server configuration error: Missing API key.' }), { status: 500, headers: { 'Content-Type': 'application/json' } });
  }

  try {
    // 1. Fetch Analysis Run details using Supabase
    const { data: analysisRunData, error: runError } = await supabaseAdmin
        .from('AnalysisRun') // Ensure table name is correct
        .select('*')
        .eq('id', runId)
        .single(); // Fetch a single record

    if (runError && runError.code !== 'PGRST116') { // Ignore "Row not found" error here
        console.error(`Supabase error fetching AnalysisRun ${runId}:`, runError);
        throw new Error(runError.message || 'Failed to fetch analysis run data');
    }

    if (!analysisRunData) {
        console.log(`AnalysisRun not found for runId: ${runId}`);
        return new NextResponse(
            JSON.stringify({ error: 'Analysis run not found' }),
            { status: 404, headers: { 'Content-Type': 'application/json' } }
        );
    }

    // 2. Fetch associated Competitors using Supabase
    const { data: competitorsData, error: competitorError } = await supabaseAdmin
        .from('Competitor') // Ensure table name is correct
        .select('*')
        .eq('analysisRunId', runId); // Filter by the foreign key

    if (competitorError) {
        console.error(`Supabase error fetching Competitors for runId ${runId}:`, competitorError);
        throw new Error(competitorError.message || 'Failed to fetch competitor data');
    }

    // --- Fetch Book Summary Content ---
    let bookSummaryContent = '';
    if (bookFilenamesParam) {
        const filenames = bookFilenamesParam.split(','); // Split the string into an array
        console.log(`Attempting to read ${filenames.length} book summaries...`);
        let summaries: string[] = []; // Store summaries temporarily

        for (const filename of filenames) {
            const safeFilename = path.basename(filename.trim()); // Trim whitespace
            if (safeFilename !== filename.trim() || !safeFilename.match(/^[^/\\.]+[\w .-]+\.(txt|md)$/i)) {
                 console.warn(`Skipping invalid book filename: ${filename}`);
                 continue; // Skip this file
            }

            const filePath = path.join(booksDirectory, safeFilename);
            try {
                const content = await fs.readFile(filePath, 'utf-8');
                console.log(`Successfully read ${safeFilename}`);
                // Add filename header for context
                summaries.push(`--- Start Summary: ${safeFilename} ---\n${content}\n--- End Summary: ${safeFilename} ---`);
            } catch (fileError: any) {
                 if (fileError.code === 'ENOENT') {
                    console.error(`Selected book summary file not found: ${filePath}`);
                 } else {
                    console.error(`Error reading book summary file ${filePath}:`, fileError);
                 }
                 // Skip this file if error reading
            }
        }
        // Join all successfully read summaries
        bookSummaryContent = summaries.join('\n\n'); 
    }
    // --- End Book Summary Fetch ---

    // --- NEW: Perform Grounded Search for Recent Client Info ---
    let groundedClientInfo = '';
    const groundingPrompt = `ขอข้อมูลของ ${analysisRunData.clientName} ข้อมูลอัพเดทล่าสุด อยากได้ข้อมูลเช่น ราคา-ค่าใช้จ่าย, จุดเด่น ข้อมูลสำคัญต่างๆ โปรโมชั่น หรือ กิจกรรมและแคมเปญล่าสุด อยากได้ข้อมูลที่สดใหม่ที่สุด`;
    console.log(`Performing grounding search for client: ${analysisRunData.clientName}`);
    try {
        const groundingPayload = {
            contents: [{ parts: [{ text: groundingPrompt }] }],
            tools: [{ "google_search": {} }],
            generationConfig: { temperature: 0.2 } // Low temp for factual retrieval
        };
        const groundingGeminiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`;
        const groundingResponse = await fetch(groundingGeminiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(groundingPayload)
        });

        if (!groundingResponse.ok) {
          // This part runs if the API call FAILS
          const errorText = await groundingResponse.text();
          console.warn(`Gemini grounding search failed (${groundingResponse.status}): ${errorText}`); // <--- THIS MUST BE RUNNING
          // ...then it skips the 'else' block...
        } else {
            // This part runs ONLY if the API call SUCCEEDS
            const groundingData = await groundingResponse.json();

            groundedClientInfo = groundingData?.candidates?.[0]?.content?.parts?.[1]?.text?.trim() || '';
            console.log("Value assigned to groundedClientInfo:", groundedClientInfo);
            // --- Log the full response ---\n            // console.log(\"Full grounding response data:\", JSON.stringify(groundingData, null, 2)); // Keep commented for now to reduce noise\n            // --- End Log ---\n\n            // --- Assign text from parts[1] to groundedClientInfo ---\n            groundedClientInfo = groundingData?.candidates?.[0]?.content?.parts?.[1]?.text?.trim() || '';\n            // ---\n\n            // --- Log the result of the assignment ---\n            console.log(\"Value assigned to groundedClientInfo:\", groundedClientInfo);\n            // ---\n\n            if (groundedClientInfo) {\n                 console.log(`Grounding search successful, extracted info for ${analysisRunData.clientName}. Length: ${groundedClientInfo.length}`);\n            } else {\n                 console.log(`Grounding search successfully completed, but NO text found in parts[1] for ${analysisRunData.clientName}.`);\n            }\n        }\n    } catch (groundingError: any) {\n        console.error("Error during Gemini grounding search:", groundingError);\n        // Proceed without grounding info if an exception occurs
        }
    } catch (groundingError: any) {
        console.error("Error during Gemini grounding search:", groundingError);
        // Proceed without grounding info if an exception occurs
    }
    // --- End Grounded Search ---

    // Prepare data for the rest of the function
    const clientInfo = {
      clientName: analysisRunData.clientName,
      market: analysisRunData.market,
      productFocus: analysisRunData.productFocus,
    };
    // Ensure competitorsData is an array (it should be from Supabase)
    const finalCompetitorsData: Competitor[] = competitorsData || [];

    console.log(`Found ${finalCompetitorsData.length} competitors for runId: ${runId}. Preparing prompt for Gemini.`);

    // 3. Summarize Competitor Data (using the fetched Supabase data)
    const competitorSummary = summarizeCompetitors(finalCompetitorsData);
    console.log("Competitor Summary:", competitorSummary);

    // 4. Construct Gemini Prompt (Revised logic)

    // Define Default Sections (placeholders will be replaced later)
    const defaultTaskText = `1.  Spark and detail **7-10 *fresh, distinctive, and engaging*** creative ideas for ${clientInfo.clientName}. Focus on concepts that can present the client's specific ${clientInfo.productFocus} from new perspectives that **spark curiosity, drive engagement, or create a memorable impression** within the ${clientInfo.market}. Ideas should build upon the client's strengths and available insights.
                              2.  **Focus on Actionable Creativity:** Ensure each recommendation translates into tangible marketing ideas (campaigns, content pillars, ad concepts). Prioritize ideas that are memorable, shareable, emotionally resonant, and push creative boundaries for this *specific client*.
                              3.  **Informed by Context:** Where available, let the \`groundedClientInfo\` and \`bookSummarySection\` inform the *relevance, timeliness, or strategic angle* of your ideas, but the core inspiration should stem from the client's fundamental product/service and market position. Use grounding to verify trends or competitor actions if needed.
                              4.  For EACH recommendation, provide the **Creative Execution Details** below. **Generate specific, compelling content for each field IN THAI LANGUAGE.**
                              5.  Populate the corresponding fields in the final JSON object. Ensure all text output is original for this request.`;
    const defaultDetailsText = `a.  **\`content_pillar\`:** กำหนดธีมเนื้อหาหลักหรือหมวดหมู่ **(ภาษาไทย)** (เช่น "เคล็ดลับฮาวทู", "เบื้องหลังการทำงาน", "เรื่องราวความสำเร็จลูกค้า", "การหักล้างความเชื่อผิดๆ", "ไลฟ์สไตล์และการใช้งาน", "ปัญหาและการแก้ไข").
                                b.  **\`product_focus\`:** ระบุ ${clientInfo.productFocus} หรือฟีเจอร์เฉพาะที่ต้องการเน้น **(ภาษาไทย)**.
                                c.  **\`concept_idea\`:** สรุปแนวคิดสร้างสรรค์หลัก (1-2 ประโยค) สำหรับการนำเสนอไอเดียนี้ **(ภาษาไทย)**.
                                d.  **\`copywriting\`:** สร้างสรรค์องค์ประกอบข้อความโฆษณาเบื้องต้น **(ภาษาไทย)**:
                                    *   **\`headline\`:** พาดหัวที่ดึงดูดความสนใจ **(ภาษาไทย)**.
                                    *   **\`sub_headline_1\`:** พาดหัวรองที่ขยายความหรือเน้นประโยชน์ **(ภาษาไทย)**.
                                    *   **\`sub_headline_2\`:** พาดหัวรองที่สอง (ถ้ามี) เพื่อเพิ่มบริบทหรือความเร่งด่วน **(ภาษาไทย)** (ใช้ \`null\` หากไม่ต้องการ).
                                    *   **\`bullets\`:** รายการจุดเด่น 2-4 ข้อที่เน้นประโยชน์หลัก, ฟีเจอร์ หรือเหตุผลที่น่าเชื่อถือ **(ภาษาไทย)**.
                                    *   **\`cta\`:** ข้อความเรียกร้องให้ดำเนินการ (Call To Action) ที่ชัดเจน **(ภาษาไทย)** (เช่น "เรียนรู้เพิ่มเติม", "ซื้อเลย", "ดูเดโม", "เข้าร่วม Waiting List", "ดาวน์โหลดคู่มือ").`;

    // Use provided sections or defaults
    let taskSectionContent = taskSectionParam ? taskSectionParam.replace(/\{clientName\}/g, clientInfo.clientName).replace(/\{market\}/g, clientInfo.market).replace(/\{productFocus\}/g, clientInfo.productFocus || 'products/services') : defaultTaskText.replace(/\{clientName\}/g, clientInfo.clientName).replace(/\{market\}/g, clientInfo.market).replace(/\{productFocus\}/g, clientInfo.productFocus || 'products/services');
    let detailsSectionContent = detailsSectionParam ? detailsSectionParam.replace(/\{productFocus\}/g, clientInfo.productFocus || 'products/services') : defaultDetailsText.replace(/\{productFocus\}/g, clientInfo.productFocus || 'products/services');

    // Build user brief section
    const userBriefSection = userBrief ? `
**Additional User Brief/Context:**
${userBrief}
` : '';

    // NEW: Use combined summaries
    const bookSummarySection = bookSummaryContent ? `\n**Optional Book Summary Contexts:**\n${bookSummaryContent}\n` : '';

    // Construct the final prompt using the determined sections
    const finalPrompt = `
You are a **Visionary Creative Director & Disruptive Marketing Strategist**, fluent in Thai and English, known for generating **award-winning, conversation-starting campaigns**. Analyze the following client information, recent grounded search results, competitor summary, and optional book context to conceptualize groundbreaking creative recommendations and their initial execution details **IN THAI**. **ALL TEXTUAL OUTPUT IN THE FINAL JSON RESPONSE MUST BE IN THAI.** **Crucially, leverage your access to real-time information via search grounding to ensure ideas are timely, relevant, and informed by the latest digital landscape.**

**Client Information:**
*   Name: ${clientInfo.clientName}
*   Market: ${clientInfo.market}
*   Product Focus: ${clientInfo.productFocus}
${userBriefSection}
${groundedClientInfo ? `\n**Recent Client Information (via Grounded Search):**\n---\n${groundedClientInfo}\n---\n` : ''}
---
*(This section provides recent context about ${clientInfo.clientName}. Consider these details alongside the core client information to ensure recommendations are timely and relevant. Use specific points from here where they offer a clear advantage or fresh angle.)*

${bookSummarySection}

**Competitor Landscape Summary:**
${competitorSummary}
*(Analyze the competitor summary, recent client info, and optional book context...)*

**Recent Client Information is Important please use it to generate creative recommendations.

**Task:**
${taskSectionContent}

**Remember: Ensure the output fields 'title', 'description', 'competitiveGap', and 'tags' within the final JSON are also generated in THAI LANGUAGE, alongside all Creative Execution Details.**

**Creative Execution Details (Per Recommendation - Populate these fields IN THAI for the JSON):**
${detailsSectionContent}

**Output Format Requirements:**
*   Return ONLY a single, valid JSON object. No introductory text, explanations, or markdown formatting (like \`\`\`json\`\`).
*   The JSON object MUST strictly follow the structure below.
*   **Crucially, the values for \`content_pillar\`, \`product_focus\`, \`concept_idea\`, and all fields within \`copywriting\` (\`headline\`, \`sub_headline_1\`, \`sub_headline_2\`, \`bullets\`, \`cta\`) MUST be generated in THAI LANGUAGE.**
*   \`title\` and \`description\` fields should also be generated in THAI LANGUAGE.
*   Use "High", "Medium", or "Low" for the impact field (bias towards "High").
*   Provide a concise "competitiveGap" string (in THAI LANGUAGE).
*   Include 2-4 relevant and specific keyword strings in the "tags" array (in THAI LANGUAGE).

**Required JSON Structure:**
\`\`\`json
{
  "recommendations": [
    {
      "title": "หัวข้อแนะนำ (ภาษาไทย)", // Thai - Must be original
      "description": "รายละเอียดแนวคิดสร้างสรรค์ ที่ไม่ซ้ำใคร และมีประสิทธิภาพ (ภาษาไทย)", // Thai - Must be original
      "category": "Campaign", // Keep category identifier standard
      "impact": "High",
      "competitiveGap": "ระบุช่องว่างทางการแข่งขันที่ไอเดียนี้เข้าไปตอบโจทย์ (ภาษาไทย)", // Thai - Must be original
      "tags": ["คำค้น1", "คำค้น2", "รูปแบบเนื้อหา"], // Thai - Must be original
      "content_pillar": "ตัวอย่าง: เคล็ดลับฮาวทู", // Thai - Must be original
      "product_focus": "ระบุ ${clientInfo.productFocus} ที่ระบุใน Input", // Thai - Must be original & specific to input
      "concept_idea": "สรุปแนวคิดสร้างสรรค์หลักสำหรับไอเดียนี้ (1-2 ประโยค)", // Thai - Must be original
      "copywriting": {
        "headline": "พาดหัวหลักที่น่าสนใจ", // Thai - Must be original
        "sub_headline_1": "พาดหัวรองสนับสนุน", // Thai - Must be original
        "sub_headline_2": "พาดหัวรองที่สอง (ถ้ามี) หรือ null", // Thai - Must be original or null
        "bullets": [
          "จุดเด่นที่ 1", // Thai - Must be original
          "จุดเด่นที่ 2", // Thai - Must be original
          "จุดเด่นที่ 3"  // Thai - Must be original
        ],
        "cta": "ตัวอย่าง: ดูเพิ่มเติม" // Thai - Must be original
      }
    }
    // ... more recommendation objects (7-10 total)
  ]
}
\`\`\`
`;

    // --- Log final prompt before saving ---\n    console.log(\"--- START FINAL PROMPT TO BE SAVED ---\");\n    console.log(finalPrompt);\n    console.log(\"--- END FINAL PROMPT TO BE SAVED ---\");\n    // --- End Log ---\n\n    // --- NEW: Save the prompt for debugging ---\n    try {
        const debugFilename = `prompt_debug_${runId}.txt`;
        await fs.writeFile(path.join(process.cwd(), debugFilename), finalPrompt);
        console.log(`Debug prompt saved to: ${debugFilename}`);
    // } catch (debugError) {
    //     console.error("Error saving debug prompt file:", debugError);
    //     // Continue execution even if saving fails
    // }
    // --- End Save Prompt ---
    
    // 5. Call Gemini API with Grounding
    console.log("Sending request to Gemini API...");
    const geminiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-04-17:generateContent?key=${GEMINI_API_KEY}`;

    const geminiPayload = {
        contents: [{ parts: [{ text: finalPrompt }] }],
        // Enable Grounding with Google Search [[reference]](https://ai.google.dev/gemini-api/docs/grounding?lang=rest)
        tools: [{
            "google_search": {}
        }],
        generationConfig: {
          temperature: 0.0 // Adjust temperature for creativity vs consistency
        }
    };

    const geminiResponse = await fetch(geminiUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(geminiPayload)
    });

    if (!geminiResponse.ok) {
      const errorText = await geminiResponse.text();
      console.error('Gemini API error response:', errorText);
      throw new Error(`Gemini API request failed: ${geminiResponse.status} - ${errorText}`);
    }

    const geminiData = await geminiResponse.json();
    console.log("Received response from Gemini API.");

    // 6. Parse and Validate Gemini's JSON Output
    const generatedText = geminiData?.candidates?.[0]?.content?.parts?.[0]?.text;

    // Log the raw response before attempting to parse
    console.log("Raw text received from Gemini:", generatedText);

    if (typeof generatedText !== 'string' || generatedText.trim() === '') {
        console.error("Gemini response missing valid text content or is empty:", geminiData);
        throw new Error('Gemini returned empty or invalid content.');
    }

    let parsedRecommendations: GeminiRecommendationOutput;
    let jsonString: string = ''; // Define jsonString in the outer scope
    try {
        // Clean potential markdown fences first (as a fallback)
        let potentiallyCleanedText = generatedText.trim().replace(/^```json\s*/, '').replace(/\s*```$/, '');

        // Find the start and end of the main JSON object
        const startIndex = potentiallyCleanedText.indexOf('{');
        const endIndex = potentiallyCleanedText.lastIndexOf('}');

        if (startIndex === -1 || endIndex === -1 || endIndex < startIndex) {
            console.error("Could not find valid JSON object delimiters {} in response:", potentiallyCleanedText);
            throw new Error('AI response did not contain a valid JSON object structure.');
        }

        // Extract the JSON string between the first { and last }
        jsonString = potentiallyCleanedText.substring(startIndex, endIndex + 1); // Assign to outer scope variable

        // Attempt to parse the extracted JSON string
        parsedRecommendations = JSON.parse(jsonString);
        console.log(`Successfully parsed ${parsedRecommendations?.recommendations?.length ?? 0} recommendations from Gemini JSON block.`);

        // Basic validation
        if (!parsedRecommendations || !Array.isArray(parsedRecommendations.recommendations)) {
           throw new Error("Parsed JSON does not contain a 'recommendations' array.");
        }

    } catch(parseError: any) {
        console.error("Failed to parse JSON from Gemini (after extraction):", jsonString, "Original text:", generatedText, "Error:", parseError);
        // Fallback or throw error - maybe return an empty array or error response
        throw new Error(`Failed to parse recommendations JSON from AI: ${parseError.message}`);
    }
    
    // Return the successfully generated and parsed recommendations
    return NextResponse.json({ recommendations: parsedRecommendations.recommendations });

  } catch (error) {
    console.error(`Error in GET /api/generate-recommendations for runId ${runId}:`, error);
    let errorMessage = 'Failed to generate recommendations';
    if (error instanceof Error) {
        errorMessage = error.message;
    }
    return new NextResponse(
      JSON.stringify({ error: errorMessage }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  } finally {
    // Optional: Disconnect Supabase
    // await supabaseAdmin.$disconnect();
  }
} 