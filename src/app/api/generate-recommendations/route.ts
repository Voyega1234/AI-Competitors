import { NextRequest, NextResponse } from 'next/server';
import { PrismaClient, AnalysisRun, Competitor } from '../../../generated/prisma'; // Adjust path if needed

const prisma = new PrismaClient();

// TODO: Define the expected structure for a recommendation generated by Gemini
interface GeneratedRecommendation {
    title: string;
    description: string;
    category: string;
    impact: string;
    competitiveGap?: string | null;
    tags?: string[] | null;
    // --- Thai Strategic Analysis Fields ---
    purpose_th: string;       // ๑. รู้เป้าหมาย
    target_audience_th: string; // ๒. รู้คนฟัง/คนใช้
    context_th: string;         // ๓. รู้บริบท
    constraints_th: string;     // ๔. รู้ข้อจำกัด
    competitors_th: string;     // ๕. รู้ว่าใครทำอะไรไปแล้ว
    untapped_potential_th: string; // ๖. รู้ว่าอะไร "ยังไม่มีใครกล้าทำ"
    // --- Creative Marketing Execution Ideas ---
    promoted_product_th: string; // Product/Service to highlight
    mood_and_tone_th: string;    // e.g., น่าเชื่อถือ, สนุกสนาน, มืออาชีพ
    key_message_th: string;      // Core message/tagline
    execution_example_th: string; // Concrete example (e.g., Facebook post idea)
}

// Expected structure from the Gemini JSON response
interface GeminiRecommendationOutput {
    recommendations: GeneratedRecommendation[];
}

// Helper function to create a concise summary of competitor data
function summarizeCompetitors(competitors: Competitor[]): string {
    if (!competitors || competitors.length === 0) {
        return "No competitor data available.";
    }

    let summary = `Analysis of ${competitors.length} competitors reveals:\n`;

    // --- Basic Service Overview ---
    const allServices = new Set<string>();
    competitors.forEach(c => c.services?.forEach(s => allServices.add(s.toLowerCase())));
    if (allServices.size > 0) {
        summary += `- Common service areas include: ${Array.from(allServices).slice(0, 5).join(', ')}${allServices.size > 5 ? '...' : ''}.\n`;
    }

    // --- Pricing Insights (Example) ---
    const pricingModels = new Set<string>();
    competitors.forEach(c => { if (c.pricing) pricingModels.add(c.pricing); });
    if (pricingModels.size > 0) {
        summary += `- Pricing models observed: ${Array.from(pricingModels).slice(0, 3).join(', ')}.\n`;
    }
    
    // --- Strengths/Weaknesses (Example) ---
    const commonStrengths = new Map<string, number>();
    const commonWeaknesses = new Map<string, number>();
    competitors.forEach(c => {
        c.strengths?.forEach(s => commonStrengths.set(s.toLowerCase(), (commonStrengths.get(s.toLowerCase()) || 0) + 1));
        c.weaknesses?.forEach(w => commonWeaknesses.set(w.toLowerCase(), (commonWeaknesses.get(w.toLowerCase()) || 0) + 1));
    });
    // Helper to get top N items from a map
    const getTopItems = (map: Map<string, number>, topN: number) => Array.from(map.entries())
                                                                          .sort((a, b) => b[1] - a[1])
                                                                          .slice(0, topN)
                                                                          .map(entry => entry[0]);

    const topStrengths = getTopItems(commonStrengths, 2);
    const topWeaknesses = getTopItems(commonWeaknesses, 2);
    if (topStrengths.length > 0) summary += `- Common competitor strengths: ${topStrengths.join(', ')}.\n`;
    if (topWeaknesses.length > 0) summary += `- Common competitor weaknesses: ${topWeaknesses.join(', ')}.\n`;

    // Add more summary points as needed (e.g., target audience, market share hints)

    return summary;
}

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;
  const runId = searchParams.get('runId');
  const GEMINI_API_KEY = process.env.NEXT_PUBLIC_GEMINI_API_KEY; // Use server-side key

  console.log(`Attempting to handle GET /api/generate-recommendations for runId: ${runId}`);

  if (!runId) {
    return new NextResponse(
      JSON.stringify({ error: 'runId query parameter is required' }),
      { status: 400, headers: { 'Content-Type': 'application/json' } }
    );
  }
  if (!GEMINI_API_KEY) {
      console.error("GEMINI_API_KEY is not set in environment variables.");
      return new NextResponse(JSON.stringify({ error: 'Server configuration error: Missing API key.' }), { status: 500, headers: { 'Content-Type': 'application/json' } });
  }

  try {
    // 1. Fetch Analysis Run details and associated Competitors
    const analysisRunWithCompetitors = await prisma.analysisRun.findUnique({
      where: {
        id: runId,
      },
      include: {
        Competitor: true, // Include all competitors linked to this run
      },
    });

    if (!analysisRunWithCompetitors) {
      console.log(`AnalysisRun not found for runId: ${runId}`);
      return new NextResponse(
        JSON.stringify({ error: 'Analysis run not found' }),
        { status: 404, headers: { 'Content-Type': 'application/json' } }
      );
    }

    const clientInfo = {
      clientName: analysisRunWithCompetitors.clientName,
      market: analysisRunWithCompetitors.market,
      productFocus: analysisRunWithCompetitors.productFocus,
      // Add other client info if needed for the prompt
    };
    const competitorsData = analysisRunWithCompetitors.Competitor;

    console.log(`Found ${competitorsData.length} competitors for runId: ${runId}. Preparing prompt for Gemini.`);

    // 2. Convert full competitor data to JSON string for the prompt
    const competitorDataJsonString = JSON.stringify(competitorsData, null, 2); // Pretty-print for readability if needed

    // Check if JSON string is too large (optional safety check - adjust limit as needed)
    const MAX_COMPETITOR_JSON_LENGTH = 30000; // Example limit (adjust based on typical data size and token limits)
    if (competitorDataJsonString.length > MAX_COMPETITOR_JSON_LENGTH) {
        console.warn(`Competitor data JSON string is very large (${competitorDataJsonString.length} chars), potentially exceeding limits. Consider summarizing or selecting key fields.`);
        // Potentially fallback to summarization or throw error if too large
        // For now, we proceed but log a warning.
    }

    // Define the JSON structure example separately to avoid linter issues
    const jsonStructureExample = `{
      "recommendations": [
        {
          "title": "ชื่อข้อเสนอแนะ (ภาษาไทย)",
          "description": "คำอธิบายอย่างละเอียด: แนวคิดหลักคืออะไร, ทำไมถึงควรทำ (อ้างอิงข้อมูลคู่แข่ง/กรณีศึกษาที่ค้นเจอ), คาดหวังผลลัพธ์อะไร... (ภาษาไทย)",
          "category": "แคมเปญ", "impact": "สูง",
          "competitiveGap": "ช่องว่างทางการแข่งขัน... (ภาษาไทย)",
          "tags": ["คำหลัก1", "คำหลัก2"],
          // Strategic Analysis Fields (Detailed)
          "purpose_th": "วิเคราะห์เป้าหมายหลักอย่างละเอียด... (ภาษาไทย)",
          "target_audience_th": "ระบุกลุ่มเป้าหมายอย่างชัดเจน... (ภาษาไทย)",
          "context_th": "อธิบายสถานการณ์ตลาดโดยละเอียด... (ภาษาไทย)",
          "constraints_th": "ระบุข้อจำกัดที่เป็นรูปธรรม... (ภาษาไทย)",
          "competitors_th": "เปรียบเทียบกับคู่แข่งอย่างละเอียด... (ภาษาไทย)",
          "untapped_potential_th": "เสนอแนะโอกาสที่ชัดเจน... (ภาษาไทย)",
          // Marketing Execution Fields (Detailed)
          "promoted_product_th": "ชื่อสินค้า/บริการที่เน้น... (ภาษาไทย)",
          "mood_and_tone_th": "น่าเชื่อถือและเชี่ยวชาญ เพราะ... (ภาษาไทย)",
          "key_message_th": "สโลแกนหลัก พร้อมคำอธิบาย... (ภาษาไทย)",
          "execution_example_th": "ตัวอย่างละเอียด: ขั้นตอนโพสต์ Facebook... (ภาษาไทย)"
        }
        // ... more recommendation objects
      ]
    }`;

    // 3. Construct Gemini Prompt
    const prompt = `\
    You are an expert marketing and business strategist AND a creative campaign specialist, fluent **exclusively in Thai**. Your goal is to generate actionable recommendations that are both strategically sound and creatively engaging. Analyze the following client information and **detailed competitor data (provided as a JSON array below)** to generate recommendations **entirely in Thai**. \
\
    \*\*Client Information (Context):\*\*\
    \*   Name: ${clientInfo.clientName}\
    \*   Market: ${clientInfo.market}\
    \*   Product Focus: ${clientInfo.productFocus}\
\
    \*\*Detailed Competitor Data (Context - JSON Array):\*\*\
    \`\`\`json\
    ${competitorDataJsonString}\
    \`\`\`\
\
    \*\*Task:\*\*\
    \*\*Your primary goal is to leverage Google Search to find relevant, successful examples (case studies, creative campaigns, innovative features) related to ${clientInfo.productFocus} from other businesses.\*\* \
    1.  **Synthesize Findings into Recommendations:** Based on your search findings AND the **detailed analysis of the provided competitor JSON**, generate 5-7 diverse recommendations for ${clientInfo.clientName}. Aim for a mix of strategic and creative/innovative ideas. Generate **detailed, comprehensive, and presentation-ready** content for each recommendation. \*\*ALL OUTPUT MUST BE IN THAI.\*\*\
        *   **Creative Focus:** When generating creative ideas, focus on tapping into **แรงจูงใจทางอารมณ์ (Emotional Motivation)**, creating **ความต่างที่คนดูแล้ว "รู้สึกอยากลอง" ทันที (a difference that evokes immediate desire)**, and achieving real **'scroll-stopping' power (พลังในการหยุดนิ้ว)**.\
    2.  **Elaborate Descriptions:** For EACH recommendation, write a **comprehensive description (in Thai)** that includes:\
        *   A clear explanation of the core idea.\
        *   The strategic rationale, explicitly linking to **specific data points in the competitor JSON** OR successful examples/case studies found via Google Search.\
        *   The expected positive outcomes or benefits for the client.\
    3.  **Justify Each Recommendation:** For every recommendation, clearly state whether it is primarily inspired by the **analysis of the competitor JSON** OR by external examples found via Google Search.\
    4.  For EACH recommendation, perform a **detailed, insightful, and specific** strategic analysis covering the points below, \*\*also in Thai\*\*. **Elaborate on each point** with sufficient justification and detail to be clear and convincing. Ensure the analysis references search findings or **specific competitor data points from the JSON** where applicable.\
    5.  **Generate Brand-Aligned, Attention-Grabbing Execution Concepts:** For EACH recommendation, provide detailed marketing execution concepts **in Thai**. **Critically evaluate: Would the target audience stop scrolling for this? Would the brand approve this creative direction?** Concepts should cover:\
        *   **Promoted Product/Service (สินค้า/บริการที่จะเน้น):** Which specific client product/service does this idea best promote? Be specific.\
        *   **Mood & Tone (อารมณ์และโทน):** What should the feeling be (e.g., น่าเชื่อถือ, สนุกสนาน, มืออาชีพ, เร่งด่วน)? **Explain why** and Reflect the desired emotional motivation.\
        *   **Key Message/Tagline (ข้อความหลัก/สโลแกน):** What is the core message or a catchy tagline? **Make technical points easy to understand (จุดขายทางเทคนิคที่พูดง่าย).** \
        *   **Execution Example (ตัวอย่างการนำไปใช้):** Describe a **detailed execution example**... **Briefly explain HOW this example achieves scroll-stopping power and aligns with the likely brand image.** Aim for immediate interest and brand appropriateness.\
    6.  Present all output in **natural, fluent, and engaging Thai.** \
    7.  Recommendations should cover areas like: แคมเปญ, โปรโมชั่น, กลยุทธ์เนื้อหา, ฟีเจอร์ใหม่, การปรับปรุงบริการ, โครงการเชิงกลยุทธ์, and creative concepts.\
 \
    \*\*Strategic Analysis Points (Generate in Thai with Specificity and Detail):\*\*\
    (Update instructions to reference the detailed JSON)\
    1.  **เป้าหมาย (Purpose):** เป้าหมายหลัก \*ที่วัดผลได้\* ของข้อเสนอนี้คืออะไร? ... (Elaborate and justify) และมันเชื่อมโยงกับจุดแข็ง/จุดอ่อนของคู่แข่ง (จาก JSON) หรือเป้าหมายลูกค้าอย่างไร?\
    2.  **คนฟัง/คนใช้ (Target Audience):** ระบุกลุ่มเป้าหมายหลัก \*อย่างเฉพาะเจาะจง\* (พิจารณาข้อมูล targetAudience จาก JSON)...\
    3.  **บริบท (Context):** \*สภาวะตลาดหรือการกระทำ/ข้อมูลของคู่แข่งใดจาก JSON\* ที่ทำให้ข้อเสนอนี้มีความสำเร็จ ... อ้างอิงข้อมูลจาก JSON ถ้าเป็นไปได้\
    4.  **ข้อจำกัด (Constraints):** ระบุข้อจำกัด \*ที่เป็นไปได้และเฉพาะเจาะจง\* ... (Elaborate beyond generic points)\
    5.  **คู่แข่ง/มาตรฐาน (Competitors/Benchmarks):** \*เปรียบเทียบข้อเสนอนี้กับสิ่งที่คู่แข่ง (จาก JSON data) กำลังทำอยู่\* ... และ/หรือ \*แนวทางที่ประสบความสำเร็จจากกรณีศึกษา/ตัวอย่างที่ค้นพบผ่าน Google Search ...\
    6.  **ศักยภาพที่ยังไม่มีใครทำ (Untapped Potential):** ... \*ต้องอ้างอิงข้อมูลจากการค้นหา หรือ ข้อมูลเฉพาะจาก competitor JSON เพื่อสนับสนุน\*\\\
 \
    \*\*Output Format Requirements:\*\*\
    \*   Return ONLY a single, valid JSON object. No introductory text, explanations, or markdown formatting (like \\\`\\\`\\\`json\\\`).\
    \*   The JSON object MUST strictly follow the structure below.\
    \*   \*\*CRITICAL: ALL text values within the JSON object MUST be in Thai language and provide sufficient detail for presentation.** This includes title, description, category, impact, competitiveGap, tags, all strategic *_th fields, **and the new marketing execution fields (promoted_product_th, mood_and_tone_th, key_message_th, execution_example_th)**.\
    \*   Use \"High\", \"Medium\", or \"Low\" for the impact field. (Reverted based on user change in previous step - user seems to prefer English impact terms)\
\
    \*\*Required JSON Structure Example:\*\*\
    ${jsonStructureExample}\
    `;

    // 4. Call Gemini API with Grounding
    console.log("Sending request to Gemini API...");
    const geminiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`;

    const geminiPayload = {
        contents: [{ parts: [{ text: prompt }] }],
        // Enable Grounding with Google Search [[reference]](https://ai.google.dev/gemini-api/docs/grounding?lang=rest)
        tools: [{
            "google_search": {}
        }],
        generationConfig: {
          temperature: 0.6 // Adjust temperature for creativity vs consistency
        }
    };

    const geminiResponse = await fetch(geminiUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(geminiPayload)
    });

    if (!geminiResponse.ok) {
      const errorText = await geminiResponse.text();
      console.error('Gemini API error response:', errorText);
      throw new Error(`Gemini API request failed: ${geminiResponse.status} - ${errorText}`);
    }

    const geminiData = await geminiResponse.json();
    console.log("Received response from Gemini API.");

    // 5. Parse and Validate Gemini's JSON Output
    const generatedText = geminiData?.candidates?.[0]?.content?.parts?.[0]?.text;
    if (typeof generatedText !== 'string' || generatedText.trim() === '') {
        console.error("Gemini response missing valid text content:", geminiData);
        throw new Error('Gemini returned empty or invalid content.');
    }

    let cleanedText: string = ''; // Declare outside try block for scope
    let parsedRecommendations: GeminiRecommendationOutput;
    try {
        // Clean potential markdown fences before parsing
        cleanedText = generatedText.trim().replace(/^```json\s*/, '').replace(/\s*```$/, '');

        // Attempt to parse the cleaned JSON string returned by Gemini
        parsedRecommendations = JSON.parse(cleanedText);
        console.log(`Successfully parsed ${parsedRecommendations?.recommendations?.length ?? 0} recommendations from Gemini.`);

        // Basic validation
        if (!parsedRecommendations || !Array.isArray(parsedRecommendations.recommendations)) {
           throw new Error("Parsed JSON does not contain a 'recommendations' array.");
        }

    } catch(parseError: any) {
        console.error("Failed to parse JSON from Gemini (after cleaning):", cleanedText, "Error:", parseError);
        // Fallback or throw error - maybe return an empty array or error response
        throw new Error(`Failed to parse recommendations JSON from AI: ${parseError.message}`);
    }
    
    // Return the successfully generated and parsed recommendations
    return NextResponse.json({ recommendations: parsedRecommendations.recommendations });

  } catch (error) {
    console.error(`Error in GET /api/generate-recommendations for runId ${runId}:`, error);
    let errorMessage = 'Failed to generate recommendations';
    if (error instanceof Error) {
        errorMessage = error.message;
    }
    return new NextResponse(
      JSON.stringify({ error: errorMessage }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  } finally {
    // Optional: Disconnect Prisma
    // await prisma.$disconnect();
  }
} 