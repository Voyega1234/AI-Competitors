import { NextRequest, NextResponse } from 'next/server';
import { PrismaClient, AnalysisRun, Competitor } from '../../../generated/prisma'; // Adjust path if needed

const prisma = new PrismaClient();

// TODO: Define the expected structure for a recommendation generated by Gemini
interface GeneratedRecommendation {
    title: string;
    description: string;
    category: string;
    impact: string;
    competitiveGap?: string | null;
    tags?: string[] | null;
    // --- Thai Strategic Analysis Fields ---
    purpose_th: string;       // ๑. รู้เป้าหมาย
    target_audience_th: string; // ๒. รู้คนฟัง/คนใช้
    context_th: string;         // ๓. รู้บริบท
    constraints_th: string;     // ๔. รู้ข้อจำกัด
    competitors_th: string;     // ๕. รู้ว่าใครทำอะไรไปแล้ว
    untapped_potential_th: string; // ๖. รู้ว่าอะไร "ยังไม่มีใครกล้าทำ"
}

// Expected structure from the Gemini JSON response
interface GeminiRecommendationOutput {
    recommendations: GeneratedRecommendation[];
}

// Helper function to create a concise summary of competitor data
function summarizeCompetitors(competitors: Competitor[]): string {
    if (!competitors || competitors.length === 0) {
        return "No competitor data available.";
    }

    let summary = `Analysis of ${competitors.length} competitors reveals:\n`;

    // --- Basic Service Overview ---
    const allServices = new Set<string>();
    competitors.forEach(c => c.services?.forEach(s => allServices.add(s.toLowerCase())));
    if (allServices.size > 0) {
        summary += `- Common service areas include: ${Array.from(allServices).slice(0, 5).join(', ')}${allServices.size > 5 ? '...' : ''}.\n`;
    }

    // --- Pricing Insights (Example) ---
    const pricingModels = new Set<string>();
    competitors.forEach(c => { if (c.pricing) pricingModels.add(c.pricing); });
    if (pricingModels.size > 0) {
        summary += `- Pricing models observed: ${Array.from(pricingModels).slice(0, 3).join(', ')}.\n`;
    }
    
    // --- Strengths/Weaknesses (Example) ---
    const commonStrengths = new Map<string, number>();
    const commonWeaknesses = new Map<string, number>();
    competitors.forEach(c => {
        c.strengths?.forEach(s => commonStrengths.set(s.toLowerCase(), (commonStrengths.get(s.toLowerCase()) || 0) + 1));
        c.weaknesses?.forEach(w => commonWeaknesses.set(w.toLowerCase(), (commonWeaknesses.get(w.toLowerCase()) || 0) + 1));
    });
    // Helper to get top N items from a map
    const getTopItems = (map: Map<string, number>, topN: number) => Array.from(map.entries())
                                                                          .sort((a, b) => b[1] - a[1])
                                                                          .slice(0, topN)
                                                                          .map(entry => entry[0]);

    const topStrengths = getTopItems(commonStrengths, 2);
    const topWeaknesses = getTopItems(commonWeaknesses, 2);
    if (topStrengths.length > 0) summary += `- Common competitor strengths: ${topStrengths.join(', ')}.\n`;
    if (topWeaknesses.length > 0) summary += `- Common competitor weaknesses: ${topWeaknesses.join(', ')}.\n`;

    // Add more summary points as needed (e.g., target audience, market share hints)

    return summary;
}

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;
  const runId = searchParams.get('runId');
  const GEMINI_API_KEY = process.env.NEXT_PUBLIC_GEMINI_API_KEY; // Use server-side key

  console.log(`Attempting to handle GET /api/generate-recommendations for runId: ${runId}`);

  if (!runId) {
    return new NextResponse(
      JSON.stringify({ error: 'runId query parameter is required' }),
      { status: 400, headers: { 'Content-Type': 'application/json' } }
    );
  }
  if (!GEMINI_API_KEY) {
      console.error("GEMINI_API_KEY is not set in environment variables.");
      return new NextResponse(JSON.stringify({ error: 'Server configuration error: Missing API key.' }), { status: 500, headers: { 'Content-Type': 'application/json' } });
  }

  try {
    // 1. Fetch Analysis Run details and associated Competitors
    const analysisRunWithCompetitors = await prisma.analysisRun.findUnique({
      where: {
        id: runId,
      },
      include: {
        Competitor: true, // Include all competitors linked to this run
      },
    });

    if (!analysisRunWithCompetitors) {
      console.log(`AnalysisRun not found for runId: ${runId}`);
      return new NextResponse(
        JSON.stringify({ error: 'Analysis run not found' }),
        { status: 404, headers: { 'Content-Type': 'application/json' } }
      );
    }

    const clientInfo = {
      clientName: analysisRunWithCompetitors.clientName,
      market: analysisRunWithCompetitors.market,
      productFocus: analysisRunWithCompetitors.productFocus,
      // Add other client info if needed for the prompt
    };
    const competitorsData = analysisRunWithCompetitors.Competitor;

    console.log(`Found ${competitorsData.length} competitors for runId: ${runId}. Preparing prompt for Gemini.`);

    // 2. Summarize Competitor Data
    const competitorSummary = summarizeCompetitors(competitorsData);
    console.log("Competitor Summary:", competitorSummary);

    // Define the JSON structure example separately to avoid linter issues
    const jsonStructureExample = `{
      "recommendations": [
        {
          "title": "ชื่อข้อเสนอแนะ (ภาษาไทย)",
          "description": "คำอธิบายโดยละเอียดเกี่ยวกับข้อเสนอแนะและเหตุผลตามการวิเคราะห์คู่แข่ง (ภาษาไทย)",
          "category": "แคมเปญ", "impact": "สูง",
          "competitiveGap": "ช่องว่างทางการแข่งขันที่ระบุ (ภาษาไทย)",
          "tags": ["คำหลัก1", "คำหลัก2"],
          "purpose_th": "วิเคราะห์เป้าหมายหลัก... (ภาษาไทย)",
          "target_audience_th": "ระบุกลุ่มเป้าหมาย... (ภาษาไทย)",
          "context_th": "อธิบายสถานการณ์... (ภาษาไทย)",
          "constraints_th": "ระบุข้อจำกัด... (ภาษาไทย)",
          "competitors_th": "เปรียบเทียบกับคู่แข่ง... (ภาษาไทย)",
          "untapped_potential_th": "เสนอแนะมุมมอง... (ภาษาไทย)"
        }
        // ... more recommendation objects
      ]
    }`;

    // 3. Construct Gemini Prompt
    const prompt = `\
    You are an expert marketing and business strategist fluent **exclusively in Thai**. Analyze the following client information and competitor summary (provided in English) to generate actionable recommendations **entirely in Thai**. \
\
    \*\*Client Information (Context):\*\*\
    \*   Name: ${clientInfo.clientName}\
    \*   Market: ${clientInfo.market}\
    \*   Product Focus: ${clientInfo.productFocus}\
\
    \*\*Competitor Landscape Summary (Context):\*\*\
    ${competitorSummary}\
\
    \*\*Task:\*\*\
    1.  Generate 5-7 diverse and actionable recommendations for ${clientInfo.clientName} to gain a competitive advantage in the ${clientInfo.market} market, specifically considering their focus on ${clientInfo.productFocus}. \*\*ALL OUTPUT MUST BE IN THAI.\*\*\
    2.  **Leverage your Google Search tool:** Find 1-2 relevant successful case studies or creative ideas from other businesses (globally or in ${clientInfo.market}) with a similar product focus (${clientInfo.productFocus}). \
    3.  **Incorporate Search Insights:** Use the findings from your search to inspire and enhance the recommendations and analysis you provide. Make the ideas more creative and grounded in real-world examples.\
    4.  For EACH recommendation, perform a concise \*\*yet insightful and specific\*\* strategic analysis covering the points below, \*\*also in Thai\*\*. \
    5.  Recommendations should cover areas like: แคมเปญ, โปรโมชั่น, กลยุทธ์เนื้อหา, ฟีเจอร์ใหม่, การปรับปรุงบริการ, or โครงการเชิงกลยุทธ์.\
\
    \*\*Strategic Analysis Points (Generate in Thai with Specificity):\*\*\
    1.  **เป้าหมาย (Purpose):** เป้าหมายหลัก \*ที่วัดผลได้\* ของข้อเสนอนี้คืออะไร? และมันเชื่อมโยงกับจุดแข็ง/จุดอ่อนของคู่แข่งหรือเป้าหมายลูกค้าอย่างไร?\
    2.  **คนฟัง/คนใช้ (Target Audience):** ระบุกลุ่มเป้าหมายหลัก \*อย่างเฉพาะเจาะจง\* (เช่น ช่างมืออาชีพในเขตกรุงเทพฯ, ผู้ใช้งาน DIY ครั้งแรก) และ \*ทำไม\* ข้อเสนอนี้จึงดึงดูดกลุ่มนี้เป็นพิเศษ?\
    3.  **บริบท (Context):** \*สภาวะตลาดหรือการกระทำของคู่แข่งใด\* ที่ทำให้ข้อเสนอนี้มีความสำคัญหรือเป็นโอกาสในตอนนี้? อ้างอิงจากข้อมูลสรุปคู่แข่งถ้าเป็นไปได้\
    4.  **ข้อจำกัด (Constraints):** ระบุข้อจำกัด \*ที่เป็นไปได้และเฉพาะเจาะจง\* มากกว่าแค่ 'งบประมาณ/ทรัพยากร' (เช่น ต้องใช้เวลาพัฒนา 6 เดือน, ต้องการพันธมิตรด้านโลจิสติกส์, อาจกระทบยอดขายสินค้าเดิม)?\
    5.  **คู่แข่ง/มาตรฐาน (Competitors/Benchmarks):** \*เปรียบเทียบข้อเสนอนี้กับสิ่งที่คู่แข่ง (ระบุชื่อ ถ้ามีในข้อมูลสรุป) กำลังทำอยู่\* และ/หรือ \*แนวทางที่ประสบความสำเร็จจากกรณีศึกษาที่ค้นพบผ่าน Google Search?\* มีตัวอย่างหรือมาตรฐานใดที่เราเทียบเคียงได้?\
    6.  **ศักยภาพที่ยังไม่มีใครทำ (Untapped Potential):** เสนอ \*ขั้นตอนแรกที่เป็นรูปธรรม\* หรือ \*ช่องว่าง/กลุ่มลูกค้าเฉพาะทาง\* ที่ข้อเสนอนี้สามารถตอบสนองได้และยังไม่มีใครทำได้ดี? \*อ้างอิงข้อมูลจากการค้นหาถ้าเป็นไปได้\*\
\
    \*\*Output Format Requirements:\*\*\
    \*   Return ONLY a single, valid JSON object. No introductory text, explanations, or markdown formatting (like \\\`\\\`\\\`json\\\`).\
    \*   The JSON object MUST strictly follow the structure below.\
    \*   \*\*CRITICAL: ALL text values within the JSON object MUST be in Thai language.\*\* This includes title, description, category, impact, competitiveGap, tags, and all *_th fields.\
    \*   Use \"High\", \"Meidum\", or \"Low\" for the impact field.\
\
    \*\*Required JSON Structure Example:\*\*\
    ${jsonStructureExample}\
    `;

    // 4. Call Gemini API with Grounding
    console.log("Sending request to Gemini API...");
    const geminiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`;

    const geminiPayload = {
        contents: [{ parts: [{ text: prompt }] }],
        // Enable Grounding with Google Search [[reference]](https://ai.google.dev/gemini-api/docs/grounding?lang=rest)
        tools: [{
            "google_search": {}
        }],
        generationConfig: {
          temperature: 0.6 // Adjust temperature for creativity vs consistency
        }
    };

    const geminiResponse = await fetch(geminiUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(geminiPayload)
    });

    if (!geminiResponse.ok) {
      const errorText = await geminiResponse.text();
      console.error('Gemini API error response:', errorText);
      throw new Error(`Gemini API request failed: ${geminiResponse.status} - ${errorText}`);
    }

    const geminiData = await geminiResponse.json();
    console.log("Received response from Gemini API.");

    // 5. Parse and Validate Gemini's JSON Output
    const generatedText = geminiData?.candidates?.[0]?.content?.parts?.[0]?.text;
    if (typeof generatedText !== 'string' || generatedText.trim() === '') {
        console.error("Gemini response missing valid text content:", geminiData);
        throw new Error('Gemini returned empty or invalid content.');
    }

    let cleanedText: string = ''; // Declare outside try block for scope
    let parsedRecommendations: GeminiRecommendationOutput;
    try {
        // Clean potential markdown fences before parsing
        cleanedText = generatedText.trim().replace(/^```json\s*/, '').replace(/\s*```$/, '');

        // Attempt to parse the cleaned JSON string returned by Gemini
        parsedRecommendations = JSON.parse(cleanedText);
        console.log(`Successfully parsed ${parsedRecommendations?.recommendations?.length ?? 0} recommendations from Gemini.`);

        // Basic validation
        if (!parsedRecommendations || !Array.isArray(parsedRecommendations.recommendations)) {
           throw new Error("Parsed JSON does not contain a 'recommendations' array.");
        }

    } catch(parseError: any) {
        console.error("Failed to parse JSON from Gemini (after cleaning):", cleanedText, "Error:", parseError);
        // Fallback or throw error - maybe return an empty array or error response
        throw new Error(`Failed to parse recommendations JSON from AI: ${parseError.message}`);
    }
    
    // Return the successfully generated and parsed recommendations
    return NextResponse.json({ recommendations: parsedRecommendations.recommendations });

  } catch (error) {
    console.error(`Error in GET /api/generate-recommendations for runId ${runId}:`, error);
    let errorMessage = 'Failed to generate recommendations';
    if (error instanceof Error) {
        errorMessage = error.message;
    }
    return new NextResponse(
      JSON.stringify({ error: errorMessage }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  } finally {
    // Optional: Disconnect Prisma
    // await prisma.$disconnect();
  }
} 