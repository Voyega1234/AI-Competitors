import { NextRequest, NextResponse } from 'next/server';
import { PrismaClient, AnalysisRun, Competitor } from '../../../generated/prisma'; // Adjust path if needed

const prisma = new PrismaClient();

// TODO: Define the expected structure for a recommendation generated by Gemini
interface GeneratedRecommendation {
    title: string;
    description: string;
    category: string; // e.g., Campaign, Promotion, Content, Feature, Initiative
    impact: string;   // e.g., High, Medium, Low
    competitiveGap?: string | null;
    tags?: string[] | null;
    // --- Add Thai Strategic Analysis Fields ---
    purpose_th: string;       // ๑. รู้เป้าหมาย
    target_audience_th: string; // ๒. รู้คนฟัง/คนใช้
    context_th: string;         // ๓. รู้บริบท
    constraints_th: string;     // ๔. รู้ข้อจำกัด
    competitors_th: string;     // ๕. รู้ว่าใครทำอะไรไปแล้ว
    untapped_potential_th: string; // ๖. รู้ว่าอะไร "ยังไม่มีใครกล้าทำ"
}

// Expected structure from the Gemini JSON response
interface GeminiRecommendationOutput {
    recommendations: GeneratedRecommendation[];
}

// Helper function to create a concise summary of competitor data
function summarizeCompetitors(competitors: Competitor[]): string {
    if (!competitors || competitors.length === 0) {
        return "No competitor data available.";
    }

    let summary = `Analysis of ${competitors.length} competitors reveals:\n`;

    // --- Basic Service Overview ---
    const allServices = new Set<string>();
    competitors.forEach(c => c.services?.forEach(s => allServices.add(s.toLowerCase())));
    if (allServices.size > 0) {
        summary += `- Common service areas include: ${Array.from(allServices).slice(0, 5).join(', ')}${allServices.size > 5 ? '...' : ''}.\n`;
    }

    // --- Pricing Insights (Example) ---
    const pricingModels = new Set<string>();
    competitors.forEach(c => { if (c.pricing) pricingModels.add(c.pricing); });
    if (pricingModels.size > 0) {
        summary += `- Pricing models observed: ${Array.from(pricingModels).slice(0, 3).join(', ')}.\n`;
    }
    
    // --- Strengths/Weaknesses (Example) ---
    const commonStrengths = new Map<string, number>();
    const commonWeaknesses = new Map<string, number>();
    competitors.forEach(c => {
        c.strengths?.forEach(s => commonStrengths.set(s.toLowerCase(), (commonStrengths.get(s.toLowerCase()) || 0) + 1));
        c.weaknesses?.forEach(w => commonWeaknesses.set(w.toLowerCase(), (commonWeaknesses.get(w.toLowerCase()) || 0) + 1));
    });
    // Helper to get top N items from a map
    const getTopItems = (map: Map<string, number>, topN: number) => Array.from(map.entries())
                                                                          .sort((a, b) => b[1] - a[1])
                                                                          .slice(0, topN)
                                                                          .map(entry => entry[0]);

    const topStrengths = getTopItems(commonStrengths, 2);
    const topWeaknesses = getTopItems(commonWeaknesses, 2);
    if (topStrengths.length > 0) summary += `- Common competitor strengths: ${topStrengths.join(', ')}.\n`;
    if (topWeaknesses.length > 0) summary += `- Common competitor weaknesses: ${topWeaknesses.join(', ')}.\n`;

    // Add more summary points as needed (e.g., target audience, market share hints)

    return summary;
}

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;
  const runId = searchParams.get('runId');
  const userBrief = searchParams.get('brief');
  const taskSectionParam = searchParams.get('taskSection');
  const detailsSectionParam = searchParams.get('detailsSection');
  const GEMINI_API_KEY = process.env.NEXT_PUBLIC_GEMINI_API_KEY; // Use server-side key

  console.log(`Attempting to handle GET /api/generate-recommendations for runId: ${runId}`);

  if (!runId) {
    return new NextResponse(
      JSON.stringify({ error: 'runId query parameter is required' }),
      { status: 400, headers: { 'Content-Type': 'application/json' } }
    );
  }
  if (!GEMINI_API_KEY) {
      console.error("GEMINI_API_KEY is not set in environment variables.");
      return new NextResponse(JSON.stringify({ error: 'Server configuration error: Missing API key.' }), { status: 500, headers: { 'Content-Type': 'application/json' } });
  }

  try {
    // 1. Fetch Analysis Run details and associated Competitors
    const analysisRunWithCompetitors = await prisma.analysisRun.findUnique({
      where: {
        id: runId,
      },
      include: {
        Competitor: true, // Include all competitors linked to this run
      },
    });

    if (!analysisRunWithCompetitors) {
      console.log(`AnalysisRun not found for runId: ${runId}`);
      return new NextResponse(
        JSON.stringify({ error: 'Analysis run not found' }),
        { status: 404, headers: { 'Content-Type': 'application/json' } }
      );
    }

    const clientInfo = {
      clientName: analysisRunWithCompetitors.clientName,
      market: analysisRunWithCompetitors.market,
      productFocus: analysisRunWithCompetitors.productFocus,
      // Add other client info if needed for the prompt
    };
    const competitorsData = analysisRunWithCompetitors.Competitor;

    console.log(`Found ${competitorsData.length} competitors for runId: ${runId}. Preparing prompt for Gemini.`);

    // 2. Summarize Competitor Data
    const competitorSummary = summarizeCompetitors(competitorsData);
    console.log("Competitor Summary:", competitorSummary);

    // 3. Construct Gemini Prompt (Revised logic)

    // Define Default Sections (placeholders will be replaced later)
    const defaultTaskText = `1.  Conceptualize and Detail **7-10 *truly distinctive and breakthrough*** creative recommendations for {clientName} to dominate attention and gain a significant competitive advantage in the {market} market, specifically bringing {productFocus} to life in novel ways.\n2.  **Crucially, these recommendations MUST be highly CREATIVE and ACTIONABLE:** Focus intensely on unique creative directions, specific content narratives, viral-potential ad concepts, and engaging execution formats. Prioritize ideas that are **memorable, shareable, and emotionally resonant**. Push the boundaries of conventional marketing creative.\n3.  **Actively use the integrated search grounding capability** to inform your recommendations (trends, competitor examples, platform formats, audience conversations, external inspiration).\n4.  For EACH recommendation, provide the **Creative Execution Details** below. **Generate specific, compelling content for each field IN THAI LANGUAGE.**\n5.  Populate the corresponding fields in the final JSON object.`;
    const defaultDetailsText = `a.  **\`content_pillar\`:** กำหนดธีมเนื้อหาหลักหรือหมวดหมู่ **(ภาษาไทย)** (เช่น \"เคล็ดลับฮาวทู\", \"เบื้องหลังการทำงาน\", \"เรื่องราวความสำเร็จลูกค้า\", \"การหักล้างความเชื่อผิดๆ\", \"ไลฟ์สไตล์และการใช้งาน\", \"ปัญหาและการแก้ไข\").\nb.  **\`product_focus\`:** ระบุ {productFocus} หรือฟีเจอร์เฉพาะที่ต้องการเน้น **(ภาษาไทย)**.\nc.  **\`concept_idea\`:** สรุปแนวคิดสร้างสรรค์หลัก (1-2 ประโยค) สำหรับการนำเสนอไอเดียนี้ **(ภาษาไทย)**.\nd.  **\`copywriting\`:** สร้างสรรค์องค์ประกอบข้อความโฆษณาเบื้องต้น **(ภาษาไทย)**:\n    *   **\`headline\`:** พาดหัวที่ดึงดูดความสนใจ **(ภาษาไทย)**.\n    *   **\`sub_headline_1\`:** พาดหัวรองที่ขยายความหรือเน้นประโยชน์ **(ภาษาไทย)**.\n    *   **\`sub_headline_2\`:** พาดหัวรองที่สอง (ถ้ามี) เพื่อเพิ่มบริบทหรือความเร่งด่วน **(ภาษาไทย)** (ใช้ \`null\` หากไม่ต้องการ).\n    *   **\`bullets\`:** รายการจุดเด่น 2-4 ข้อที่เน้นประโยชน์หลัก, ฟีเจอร์ หรือเหตุผลที่น่าเชื่อถือ **(ภาษาไทย)**.\n    *   **\`cta\`:** ข้อความเรียกร้องให้ดำเนินการ (Call To Action) ที่ชัดเจน **(ภาษาไทย)** (เช่น \"เรียนรู้เพิ่มเติม\", \"ซื้อเลย\", \"ดูเดโม\", \"เข้าร่วม Waiting List\", \"ดาวน์โหลดคู่มือ\").`;

    // Use provided sections or defaults
    let taskSectionContent = taskSectionParam ? taskSectionParam.replace(/\{clientName\}/g, clientInfo.clientName).replace(/\{market\}/g, clientInfo.market).replace(/\{productFocus\}/g, clientInfo.productFocus || 'products/services') : defaultTaskText.replace(/\{clientName\}/g, clientInfo.clientName).replace(/\{market\}/g, clientInfo.market).replace(/\{productFocus\}/g, clientInfo.productFocus || 'products/services');
    let detailsSectionContent = detailsSectionParam ? detailsSectionParam.replace(/\{productFocus\}/g, clientInfo.productFocus || 'products/services') : defaultDetailsText.replace(/\{productFocus\}/g, clientInfo.productFocus || 'products/services');

    // Build user brief section
    const userBriefSection = userBrief ? `
**Additional User Brief/Context:**
${userBrief}
` : '';

    // Construct the final prompt using the determined sections
    const finalPrompt = `
You are a **Visionary Creative Director & Disruptive Marketing Strategist**, fluent in Thai and English, known for generating **award-winning, conversation-starting campaigns**. Analyze the following client information and competitor summary to conceptualize groundbreaking creative recommendations and their initial execution details **in Thai**. **Crucially, leverage your access to real-time information via search grounding to ensure ideas are timely, relevant, and informed by the latest digital landscape.**

**Client Information:**
*   Name: ${clientInfo.clientName}
*   Market: ${clientInfo.market}
*   Product Focus: ${clientInfo.productFocus}
${userBriefSection}

**Competitor Landscape Summary:**
${competitorSummary}
*(Analyze this summary not just for what competitors *do*, but for **what they *don't* do well**, where their creative is **predictable or stale**, and identify **clear white spaces** for ${clientInfo.clientName} to own. **Use search grounding to supplement this summary with recent competitor activities or emerging players if needed.**)*

**Task:**
${taskSectionContent}

**Creative Execution Details (Per Recommendation - Populate these fields IN THAI for the JSON):**
${detailsSectionContent}

**Output Format Requirements:**
*   Return ONLY a single, valid JSON object. No introductory text, explanations, or markdown formatting (like \`\`\`json\`\`).
*   The JSON object MUST strictly follow the structure below.
*   **Crucially, the values for \`content_pillar\`, \`product_focus\`, \`concept_idea\`, and all fields within \`copywriting\` (\`headline\`, \`sub_headline_1\`, \`sub_headline_2\`, \`bullets\`, \`cta\`) MUST be generated in THAI LANGUAGE.**
*   \`title\` and \`description\` fields should remain in English/Original language.
*   Use "High", "Medium", or "Low" for the impact field (bias towards "High").
*   Provide a concise "competitiveGap" string (in English/Original).
*   Include 2-4 relevant and specific keyword strings in the "tags" array (in English/Original).

**Required JSON Structure:**
\`\`\`json
{
  "recommendations": [
    {
      "title": "หัวข้อแนะนำ (ภาษาไทย)", // Thai - Must be original
      "description": "รายละเอียดแนวคิดสร้างสรรค์ ที่ไม่ซ้ำใคร และมีประสิทธิภาพ (ภาษาไทย)", // Thai - Must be original
      "category": "Campaign", // Keep category identifier standard
      "impact": "High",
      "competitiveGap": "ระบุช่องว่างทางการแข่งขันที่ไอเดียนี้เข้าไปตอบโจทย์ (ภาษาไทย)", // Thai - Must be original
      "tags": ["คำค้น1", "คำค้น2", "รูปแบบเนื้อหา"], // Thai - Must be original
      "content_pillar": "ตัวอย่าง: เคล็ดลับฮาวทู", // Thai - Must be original
      "product_focus": "ระบุ ${clientInfo.productFocus} ที่ระบุใน Input", // Thai - Must be original & specific to input
      "concept_idea": "สรุปแนวคิดสร้างสรรค์หลักสำหรับไอเดียนี้ (1-2 ประโยค)", // Thai - Must be original
      "copywriting": {
        "headline": "พาดหัวหลักที่น่าสนใจ", // Thai - Must be original
        "sub_headline_1": "พาดหัวรองสนับสนุน", // Thai - Must be original
        "sub_headline_2": "พาดหัวรองที่สอง (ถ้ามี) หรือ null", // Thai - Must be original or null
        "bullets": [
          "จุดเด่นที่ 1", // Thai - Must be original
          "จุดเด่นที่ 2", // Thai - Must be original
          "จุดเด่นที่ 3"  // Thai - Must be original
        ],
        "cta": "ตัวอย่าง: ดูเพิ่มเติม" // Thai - Must be original
      }
    }
    // ... more recommendation objects (7-10 total)
  ]
}
\`\`\`
`;

    // 4. Call Gemini API with Grounding
    console.log("Sending request to Gemini API...");
    const geminiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-04-17:generateContent?key=${GEMINI_API_KEY}`;

    const geminiPayload = {
        contents: [{ parts: [{ text: finalPrompt }] }],
        // Enable Grounding with Google Search [[reference]](https://ai.google.dev/gemini-api/docs/grounding?lang=rest)
        tools: [{
            "google_search": {}
        }],
        generationConfig: {
          temperature: 0.8 // Adjust temperature for creativity vs consistency
        }
    };

    const geminiResponse = await fetch(geminiUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(geminiPayload)
    });

    if (!geminiResponse.ok) {
      const errorText = await geminiResponse.text();
      console.error('Gemini API error response:', errorText);
      throw new Error(`Gemini API request failed: ${geminiResponse.status} - ${errorText}`);
    }

    const geminiData = await geminiResponse.json();
    console.log("Received response from Gemini API.");

    // 5. Parse and Validate Gemini's JSON Output
    const generatedText = geminiData?.candidates?.[0]?.content?.parts?.[0]?.text;
    if (typeof generatedText !== 'string' || generatedText.trim() === '') {
        console.error("Gemini response missing valid text content:", geminiData);
        throw new Error('Gemini returned empty or invalid content.');
    }

    let cleanedText: string = ''; // Declare outside try block for scope
    let parsedRecommendations: GeminiRecommendationOutput;
    try {
        // Clean potential markdown fences before parsing
        cleanedText = generatedText.trim().replace(/^```json\s*/, '').replace(/\s*```$/, '');

        // Attempt to parse the cleaned JSON string returned by Gemini
        parsedRecommendations = JSON.parse(cleanedText);
        console.log(`Successfully parsed ${parsedRecommendations?.recommendations?.length ?? 0} recommendations from Gemini.`);

        // Basic validation
        if (!parsedRecommendations || !Array.isArray(parsedRecommendations.recommendations)) {
           throw new Error("Parsed JSON does not contain a 'recommendations' array.");
        }

    } catch(parseError: any) {
        console.error("Failed to parse JSON from Gemini (after cleaning):", cleanedText, "Error:", parseError);
        // Fallback or throw error - maybe return an empty array or error response
        throw new Error(`Failed to parse recommendations JSON from AI: ${parseError.message}`);
    }
    
    // Return the successfully generated and parsed recommendations
    return NextResponse.json({ recommendations: parsedRecommendations.recommendations });

  } catch (error) {
    console.error(`Error in GET /api/generate-recommendations for runId ${runId}:`, error);
    let errorMessage = 'Failed to generate recommendations';
    if (error instanceof Error) {
        errorMessage = error.message;
    }
    return new NextResponse(
      JSON.stringify({ error: errorMessage }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  } finally {
    // Optional: Disconnect Prisma
    // await prisma.$disconnect();
  }
} 