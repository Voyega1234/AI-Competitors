import { NextRequest, NextResponse } from 'next/server';
import supabaseAdmin from '@/lib/supabaseClient'; // Import Supabase client
import fs from 'fs/promises'; // Add fs import
import path from 'path'; // Add path import

// Define interfaces for API responses and data structures
interface RecommendationObject {
  title: string;
  description: string;
  category: string;
  impact: string;
  content_pillar: string;
  product_focus: string;
  concept_idea: string;
  copywriting: {
    headline: string;
    sub_headline_1: string;
    sub_headline_2: string | null;
    bullets: string[];
    cta: string;
  };
  // Optional fields that might be present
  tags?: string[] | null;
  competitiveGap?: string | null;
  purpose_th?: string;
  target_audience_th?: string;
  context_th?: string;
  constraints_th?: string;
  competitors_th?: string;
  untapped_potential_th?: string;
  promoted_product_th?: string;
  mood_and_tone_th?: string;
  key_message_th?: string;
  execution_example_th?: string;
}

// Define the structure for a recommendation generated by Gemini
interface GeneratedRecommendation {
    title: string;
    description: string;
    category: string; // e.g., Campaign, Promotion, Content, Feature, Initiative
    impact: string;   // e.g., High, Medium, Low
    competitiveGap?: string | null;
    tags?: string[] | null;
    // --- Add Thai Strategic Analysis Fields ---
    purpose_th?: string;       // ๑. รู้เป้าหมาย
    target_audience_th?: string; // ๒. รู้คนฟัง/คนใช้
    context_th?: string;         // ๓. รู้บริบท
    constraints_th?: string;     // ๔. รู้ข้อจำกัด
    competitors_th?: string;     // ๕. รู้ว่าใครทำอะไรไปแล้ว
    untapped_potential_th?: string; // ๖. รู้ว่าอะไร "ยังไม่มีใครกล้าทำ"
}

// Expected structure from the Gemini JSON response
interface GeminiRecommendationOutput {
    recommendations: GeneratedRecommendation[];
}

// Define the path to the book summaries directory (should match the one in /api/book-summaries)
const booksDirectory = path.join(process.cwd(), 'src', 'app', 'api', 'generate-recommendations', 'books_prompts');

// Helper function to create a concise summary of competitor data
function summarizeCompetitors(competitors: Competitor[]): string {
    if (!competitors || competitors.length === 0) {
        return "No competitor data available.";
    }

    let summary = `Analysis of ${competitors.length} competitors reveals:\n`;

    // --- Basic Service Overview ---
    const allServices = new Set<string>();
    competitors.forEach(c => c.services?.forEach(s => allServices.add(s.toLowerCase())));
    if (allServices.size > 0) {
        summary += `- Common service areas include: ${Array.from(allServices).slice(0, 5).join(', ')}${allServices.size > 5 ? '...' : ''}.\n`;
    }

    // --- Pricing Insights (Example) ---
    const pricingModels = new Set<string>();
    competitors.forEach(c => { if (c.pricing) pricingModels.add(c.pricing); });
    if (pricingModels.size > 0) {
        summary += `- Pricing models observed: ${Array.from(pricingModels).slice(0, 3).join(', ')}.\n`;
    }
    
    // --- Strengths/Weaknesses (Example) ---
    const commonStrengths = new Map<string, number>();
    const commonWeaknesses = new Map<string, number>();
    competitors.forEach(c => {
        c.strengths?.forEach(s => commonStrengths.set(s.toLowerCase(), (commonStrengths.get(s.toLowerCase()) || 0) + 1));
        c.weaknesses?.forEach(w => commonWeaknesses.set(w.toLowerCase(), (commonWeaknesses.get(w.toLowerCase()) || 0) + 1));
    });
    // Helper to get top N items from a map
    const getTopItems = (map: Map<string, number>, topN: number) => Array.from(map.entries())
                                                                          .sort((a, b) => b[1] - a[1])
                                                                          .slice(0, topN)
                                                                          .map(entry => entry[0]);

    const topStrengths = getTopItems(commonStrengths, 2);
    const topWeaknesses = getTopItems(commonWeaknesses, 2);
    if (topStrengths.length > 0) summary += `- Common competitor strengths: ${topStrengths.join(', ')}.\n`;
    if (topWeaknesses.length > 0) summary += `- Common competitor weaknesses: ${topWeaknesses.join(', ')}.\n`;

    // Add more summary points as needed (e.g., target audience, market share hints)

    return summary;
}

// Define a basic Competitor type matching Supabase table structure (adjust if needed)
interface Competitor {
  id: string; // Or number depending on your schema
  analysisRunId: string; // Foreign key
  name?: string | null;
  services?: string[] | null;
  pricing?: string | null;
  strengths?: string[] | null;
  weaknesses?: string[] | null;
  targetAudience?: string | null;
  // Add other fields from your Competitor table
}

// Define AnalysisRun type matching Supabase table structure (adjust if needed)
interface AnalysisRun {
  id: string;
  clientName: string;
  market: string;
  productFocus: string | null;
  // Add other fields from your AnalysisRun table
}

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;
  const runId = searchParams.get('runId');
  const userBrief = searchParams.get('brief');
  const taskSectionParam = searchParams.get('taskSection');
  const detailsSectionParam = searchParams.get('detailsSection');
  // const bookFilenamesParam = searchParams.get('bookFilenames'); // REMOVED - Now reading all books
  const modelsParam = searchParams.get('models'); // NEW: Read models parameter
  const GEMINI_API_KEY = process.env.NEXT_PUBLIC_GEMINI_API_KEY;
  const OPENAI_API_KEY = process.env.NEXT_PUBLIC_OPENAI_API_KEY; // Read OpenAI Key
  const ANTHROPIC_API_KEY = process.env.NEXT_PUBLIC_ANTHROPIC_API_KEY; // Read Anthropic Key

  // TODO: Add OPENAI_API_KEY and CLAUDE_API_KEY later

  // --- Validation ---
  if (!runId) {
    return new NextResponse(JSON.stringify({ error: 'runId query parameter is required' }), { status: 400 });
  }
  if (!modelsParam) {
    return new NextResponse(JSON.stringify({ error: 'models query parameter is required' }), { status: 400 });
  }
  const requestedModels = modelsParam.split(',').map(m => m.trim().toLowerCase()); // Parse and normalize
  if (requestedModels.length === 0) {
    return new NextResponse(JSON.stringify({ error: 'No models specified in models parameter' }), { status: 400 });
  }
  if (requestedModels.includes('gemini') && !GEMINI_API_KEY) {
    console.error("GEMINI_API_KEY is not set.");
    return new NextResponse(JSON.stringify({ error: 'Server configuration error: Missing Gemini API key.' }), { status: 500 });
  }
  if (requestedModels.includes('openai') && !OPENAI_API_KEY) { // Check for OpenAI key
    console.error("OPENAI_API_KEY is not set.");
    return new NextResponse(JSON.stringify({ error: 'Server configuration error: Missing OpenAI API key.' }), { status: 500 });
  }
  if (requestedModels.includes('claude') && !ANTHROPIC_API_KEY) { // Check for Anthropic key
    console.error("ANTHROPIC_API_KEY is not set.");
    return new NextResponse(JSON.stringify({ error: 'Server configuration error: Missing Anthropic API key.' }), { status: 500 });
  }
  // TODO: Add checks for OpenAI/Claude keys when implemented

  console.log(`Handling GET /api/generate-recommendations for runId: ${runId}, Models: ${requestedModels.join(', ')}`);

  // --- Initialize result holders ---
  const finalResults: Record<string, any> = {};
  const finalErrors: Record<string, any> = {};

  try {
    // --- Fetch common data (needed by all models) ---
    const { data: analysisRunData, error: runError } = await supabaseAdmin
        .from('AnalysisRun') // Ensure table name is correct
        .select('*')
        .eq('id', runId)
        .single(); // Fetch a single record

    if (runError && runError.code !== 'PGRST116') { // Ignore "Row not found" error here
        console.error(`Supabase error fetching AnalysisRun ${runId}:`, runError);
        throw new Error(runError.message || 'Failed to fetch analysis run data');
    }

    if (!analysisRunData) {
        console.log(`AnalysisRun not found for runId: ${runId}`);
        return new NextResponse(
            JSON.stringify({ error: 'Analysis run not found' }),
            { status: 404, headers: { 'Content-Type': 'application/json' } }
        );
    }

    // 2. Fetch associated Competitors using Supabase
    const { data: competitorsData, error: competitorError } = await supabaseAdmin
        .from('Competitor') // Ensure table name is correct
        .select('*')
        .eq('analysisRunId', runId); // Filter by the foreign key

    if (competitorError) {
        console.error(`Supabase error fetching Competitors for runId ${runId}:`, competitorError);
        throw new Error(competitorError.message || 'Failed to fetch competitor data');
    }

    // --- Fetch and Concatenate ALL Book Summary Content ---
    let bookSummaryContent = '';
    console.log(`Attempting to read ALL book summaries from: ${booksDirectory}`);
    try {
        const allFiles = await fs.readdir(booksDirectory);
        const bookFiles = allFiles.filter(file => file.match(/\.(txt|md)$/i)); // Filter for .txt or .md
        console.log(`Found ${bookFiles.length} potential book summary files.`);
        let summaries: string[] = [];

        for (const filename of bookFiles) {
            const filePath = path.join(booksDirectory, filename);
            try {
                const content = await fs.readFile(filePath, 'utf-8');
                console.log(`Successfully read ${filename}`);
                summaries.push(`--- Start Summary: ${filename} ---\n${content}\n--- End Summary: ${filename} ---`);
            } catch (fileError: any) {
                console.error(`Error reading book summary file ${filePath}:`, fileError);
                // Skip this file if error reading, but log it
            }
        }
        bookSummaryContent = summaries.join('\n\n'); 
        console.log(`Total combined book summary length: ${bookSummaryContent.length}`);
    } catch (dirError: any) {
        if (dirError.code === 'ENOENT') {
            console.warn(`Book summaries directory not found: ${booksDirectory}. Proceeding without book context.`);
        } else {
            console.error(`Error reading book summaries directory ${booksDirectory}:`, dirError);
        }
        // Proceed without book summaries if directory reading fails
    }
    // --- End Book Summary Fetch ---

    // --- Prepare Common Prompt Components (Build ONCE) ---
    const clientInfo = { clientName: analysisRunData.clientName, market: analysisRunData.market, productFocus: analysisRunData.productFocus, };
    const competitorSummary = summarizeCompetitors(competitorsData || []);
    const bookSummarySection = bookSummaryContent ? `
**Optional Book Summary Contexts:**
${bookSummaryContent}
` : '';
    const userBriefSection = userBrief ? `
**Additional User Brief/Context:**
${userBrief}
` : '';

    // Define default prompt sections (using variables from frontend if passed)
    const defaultTaskText = `1. Spark and detail 7-10 fresh, distinctive, and engaging creative ideas for ${clientInfo.clientName}, specifically focusing on concepts highly suitable for Facebook Ad campaigns. Focus on concepts that can present the client's specific ${clientInfo.productFocus} from new perspectives that spark curiosity, drive engagement, or create a memorable impression within the ${clientInfo.market} on social media. Ideas should build upon the client's strengths and available insights.
  2. Focus on Actionable Creativity for Facebook: Ensure each recommendation translates into tangible marketing ideas easily adaptable into compelling Facebook Ad formats (e.g., single image/video, carousel, stories, reels). Include potential ad angles, visual directions, and calls-to-action. Prioritize ideas that are visually arresting, memorable, shareable, emotionally resonant, and push creative boundaries for this specific client on Facebook.
  3. Informed by Context: Where available, let the \`groundedClientInfo\` and \`bookSummarySection\` inform the relevance, timeliness, or strategic angle of your ideas, but the core inspiration should stem from the client's fundamental product/service and market position. Use grounding to verify trends or competitor actions if needed.
  4. For EACH recommendation, provide the Creative Execution Details below, specifically tailored for a Facebook Ad context. Generate specific, compelling content for each field IN THAI LANGUAGE, imagining how the core idea translates into ad components (e.g., Headline, Ad Copy, Visual Description, Call-to-Action).
  5. Populate the corresponding fields in the final JSON object. Ensure all text output is original for this request
  6. Ideas to include but not limited to: why the solutions from ${clientInfo.clientName} are different than what is being offered in the market currently. Talk about the differentiation of the product if and when it makes the client's product or service more appealing. `;
    const defaultDetailsText = `a.  **\`content_pillar\`:** กำหนดธีมเนื้อหาหลักหรือหมวดหมู่ **(ภาษาไทย)** (เช่น "เคล็ดลับฮาวทู", "เบื้องหลังการทำงาน", "เรื่องราวความสำเร็จลูกค้า", "การหักล้างความเชื่อผิดๆ", "ไลฟ์สไตล์และการใช้งาน", "ปัญหาและการแก้ไข").
                                b.  **\`product_focus\`:** ระบุ ${clientInfo.productFocus || 'ผลิตภัณฑ์/บริการ'} ที่ต้องการเน้น **(ภาษาไทย)**.
                                c.  **\`concept_idea\`:** สรุปแนวคิดสร้างสรรค์หลัก (1-2 ประโยค) สำหรับการนำเสนอไอเดียนี้ **(ภาษาไทย)**.
                                d.  **\`copywriting\`:** สร้างสรรค์องค์ประกอบข้อความโฆษณาเบื้องต้น **(ภาษาไทย)**:
                                    *   **\`headline\`:** พาดหัวที่ดึงดูดความสนใจ **(ภาษาไทย)**.
                                    *   **\`sub_headline_1\`:** พาดหัวรองที่ขยายความหรือเน้นประโยชน์ **(ภาษาไทย)**.
                                    *   **\`sub_headline_2\`:** พาดหัวรองที่สอง (ถ้ามี) เพื่อเพิ่มบริบทหรือความเร่งด่วน **(ภาษาไทย)** (ใช้ \`null\` หากไม่ต้องการ).
                                    *   **\`bullets\`:** รายการจุดเด่น 2-4 ข้อที่เน้นประโยชน์หลัก, ฟีเจอร์ หรือเหตุผลที่น่าเชื่อถือ **(ภาษาไทย)**.
                                    *   **\`cta\`:** ข้อความเรียกร้องให้ดำเนินการ (Call To Action) ที่ชัดเจน **(ภาษาไทย)** (เช่น "เรียนรู้เพิ่มเติม", "ซื้อเลย", "ดูเดโม", "เข้าร่วม Waiting List", "ดาวน์โหลดคู่มือ").`;

    let taskSectionContent = taskSectionParam ? taskSectionParam.replace(/\{clientName\}/g, clientInfo.clientName).replace(/\{market\}/g, clientInfo.market).replace(/\{productFocus\}/g, clientInfo.productFocus || 'products/services') : defaultTaskText; // Use defaults directly if param missing
    let detailsSectionContent = detailsSectionParam ? detailsSectionParam.replace(/\{productFocus\}/g, clientInfo.productFocus || 'products/services') : defaultDetailsText; // Use defaults directly if param missing

    // Define the System Prompt (primarily for Claude, but can be logged for context)
    const systemPrompt = "You are an AI assistant tasked with generating creative marketing recommendations. Your response MUST be a single, valid JSON object and nothing else. Do not include any text before or after the JSON object. All text content within the JSON object MUST be in THAI language.";

    // --- Perform Grounding Search (Run ONCE if Gemini Key exists, used by all models) ---
    let groundedClientInfoCommon = '';
    if (GEMINI_API_KEY) { // Only attempt grounding if the key is available
        const groundingPrompt = `ขอข้อมูลของ ${analysisRunData.clientName} ข้อมูลอัพเดทล่าสุด อยากได้ข้อมูลเช่น ราคา-ค่าใช้จ่าย, จุดเด่น ข้อมูลสำคัญต่างๆ โปรโมชั่น หรือ กิจกรรมและแคมเปญล่าสุด อยากได้ข้อมูลที่สดใหม่ที่สุด ตอบแค่คำตอบเท่านั้นห้ามตลอดอะไรมากกว่านี้`;
        console.log(`[Refactor] Performing common grounding search for client: ${analysisRunData.clientName}`);
        try {
            const groundingPayload = {
                contents: [{ parts: [{ text: groundingPrompt }] }],
                tools: [{ "google_search": {} }],
                generationConfig: { temperature: 0.2 } // Low temp for factual retrieval
            };
            const groundingGeminiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`; // Use Flash for grounding
            const groundingResponse = await fetch(groundingGeminiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(groundingPayload)
            });

            if (!groundingResponse.ok) {
                const errorText = await groundingResponse.text();
                console.warn(`[Refactor] Common grounding search failed (${groundingResponse.status}): ${errorText}`);
            } else {
                const groundingData = await groundingResponse.json();
                // Check tool calls response structure (adjust logic based on actual Gemini response format for tool calls)
                const functionResponse = groundingData?.candidates?.[0]?.content?.parts?.find((part: any) => part.functionResponse);
                if (functionResponse?.functionResponse?.name === 'google_search') { // More specific check
                     groundedClientInfoCommon = functionResponse.functionResponse.text || ''; // Adjust based on actual structure
                     console.log(`[Refactor] Common grounding successful via tool call. Length: ${groundedClientInfoCommon.length}`);
                } else {
                     // Fallback: check for direct text response (less likely)
                     groundedClientInfoCommon = groundingData?.candidates?.[0]?.content?.parts?.[1]?.text?.trim() || '';
                     if (groundedClientInfoCommon) {
                         console.log(`[Refactor] Common grounding returned direct text (fallback). Length: ${groundedClientInfoCommon.length}`);
                     } else {
                         console.log(`[Refactor] Common grounding completed, but NO relevant text found in response.`);
                     }
                }
            }
        } catch (groundingError: any) {
            console.error("[Refactor] Error during common grounding search:", groundingError);
            // Proceed without grounding info if search fails
        }
    } else {
        console.log("[Refactor] Skipping common grounding search as Gemini API key is not set.");
    }
    // --- End Grounding Search ---

    // --- Function to build the final user prompt (dynamically includes grounded info) ---
    const buildFinalUserPrompt = (groundedInfo: string) => {
        const groundedSection = groundedInfo ? `
---
*(This section provides recent context about ${clientInfo.clientName}. Consider these details alongside the core client information to ensure recommendations are timely and relevant. Use specific points from here where they offer a clear advantage or fresh angle.)*
` : '';

        return `
Analyze the following client information, recent grounded search results (if available), competitor summary, and optional book context to conceptualize groundbreaking creative recommendations and their initial execution details **IN THAI**. **ALL TEXTUAL OUTPUT IN THE FINAL JSON RESPONSE MUST BE IN THAI.** **Crucially, leverage your access to real-time information via search grounding (if applicable to the model/call) to ensure ideas are timely, relevant, and informed by the latest digital landscape.**

**Client Information:**
*   Name: ${clientInfo.clientName}
*   Market: ${clientInfo.market}
*   Product Focus: ${clientInfo.productFocus}
${userBriefSection}
${groundedSection}
${bookSummarySection}
**Competitor Landscape Summary:**
${competitorSummary}
*(Analyze the competitor summary, recent client info, and optional book context...)*

**Task:**
${taskSectionContent} use ${groundedClientInfoCommon} to generate recommendations ideas that respresent จุดเด่น, ผลิตภัณฑ์เด่น, โปรโมชั่น แคมเปญล่าสุด หรือ กิจกรรมล่าสุด หรือ ข้อมูลสำคัญต่างๆ 

**Creative Execution Details (Per Recommendation - Populate these fields IN THAI for the JSON):**
${detailsSectionContent}

**Output Format Requirements:**
*   Return ONLY a single, valid JSON object. No introductory text, explanations, or markdown formatting (like \`\`\`json\`\`).
*   The JSON object MUST strictly follow the structure below.
*   **Crucially, the values for \`content_pillar\`, \`product_focus\`, \`concept_idea\`, and all fields within \`copywriting\` (\`headline\`, \`sub_headline_1\`, \`sub_headline_2\`, \`bullets\`, \`cta\`) MUST be generated in THAI LANGUAGE.**
*   \`title\` and \`description\` fields should also be generated in THAI LANGUAGE.
*   Use "High", "Medium", or "Low" for the impact field (bias towards "High").
*   Provide a concise "competitiveGap" string (in THAI LANGUAGE).
*   Include 2-4 relevant and specific keyword strings in the "tags" array (in THAI LANGUAGE).

**Required JSON Structure:**
\`\`\`json
{
  "recommendations": [
    {
      "title": "หัวข้อแนะนำ (ภาษาไทย)", // Thai - Must be original
      "description": "รายละเอียดแนวคิดสร้างสรรค์ ที่ไม่ซ้ำใคร และมีประสิทธิภาพ (ภาษาไทย)", // Thai - Must be original
      "category": "Campaign", // Keep category identifier standard
      "impact": "High",
      "competitiveGap": "ระบุช่องว่างทางการแข่งขันที่ไอเดียนี้เข้าไปตอบโจทย์ (ภาษาไทย)", // Thai - Must be original
      "tags": ["คำค้น1", "คำค้น2", "รูปแบบเนื้อหา"], // Thai - Must be original
      "content_pillar": "ตัวอย่าง: เคล็ดลับฮาวทู", // Thai - Must be original
      "product_focus": "ระบุ ${clientInfo.productFocus || 'ผลิตภัณฑ์/บริการ'} ที่ระบุใน Input", // Thai - Must be original & specific to input
      "concept_idea": "สรุปแนวคิดสร้างสรรค์หลักสำหรับการนำเสนอไอเดียนี้ (1-2 ประโยค)", // Thai - Must be original
      "copywriting": {
        "headline": "พาดหัวหลักที่ดึงดูดความสนใจ", // Thai - Must be original
        "sub_headline_1": "พาดหัวรองสนับสนุน", // Thai - Must be original
        "sub_headline_2": "พาดหัวรองที่สอง (ถ้ามี) หรือ null", // Thai - Must be original or null
        "bullets": [
          "จุดเด่นที่ 1", // Thai - Must be original
          "จุดเด่นที่ 2", // Thai - Must be original
          "จุดเด่นที่ 3"  // Thai - Must be original
        ],
        "cta": "ตัวอย่าง: ดูเพิ่มเติม" // Thai - Must be original
      }
    }
    // ... more recommendation objects (7-10 total)
  ]
}
\`\`\`
`;
    };


    // --- Model-Specific Generation ---

    // --- Gemini Generation (Conditional) ---
    if (requestedModels.includes('gemini')) {
        console.log("Starting Gemini generation...");
        try {
            // --- Prepare Gemini Prompt (using common builder) ---
            const finalGeminiPrompt = buildFinalUserPrompt(groundedClientInfoCommon);

            // --- Log Gemini Prompt ---
            console.log("--- START FINAL GEMINI PROMPT ---");
            console.log(finalGeminiPrompt);
            console.log("--- END FINAL GEMINI PROMPT ---");


            // --- Call Gemini API ---
            console.log("Sending request to Gemini API...");
            const geminiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-04-17:generateContent?key=${GEMINI_API_KEY}`; // Use Pro for main generation
            const geminiPayload = {
                contents: [{ parts: [{ text: finalGeminiPrompt }] }],
                // Grounding is implicitly part of the prompt text now, remove explicit tool call for main generation
                // tools: [{ "google_search": {} }], // Removed for main generation
                generationConfig: { 
                    temperature: 0.0, // Adjusted temperature for creativity
                    response_mime_type: "application/json", // Request JSON output directly
                } 
            };
            const geminiResponse = await fetch(geminiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(geminiPayload)
            });

            if (!geminiResponse.ok) {
                const errorText = await geminiResponse.text();
                throw new Error(`Gemini API request failed: ${geminiResponse.status} - ${errorText}`);
            }
            const geminiData = await geminiResponse.json();
            // With response_mime_type, the text should be JSON directly
            const generatedText = geminiData?.candidates?.[0]?.content?.parts?.[0]?.text; 
            if (typeof generatedText !== 'string' || generatedText.trim() === '') {
                console.error("Gemini response missing text part:", JSON.stringify(geminiData, null, 2));
                throw new Error('Gemini returned empty or invalid content.');
            }

            // --- Parse Gemini Response ---
            let parsedRecommendations: GeminiRecommendationOutput;
            let jsonString = generatedText.trim(); // Assume direct JSON string
            try {
                 // No need to clean ```json markers if response_mime_type is set
                // let potentiallyCleanedText = generatedText.trim().replace(/^```json\s*/, '').replace(/\s*```$/, '');
                // const startIndex = potentiallyCleanedText.indexOf('{');
                // const endIndex = potentiallyCleanedText.lastIndexOf('}');
                // if (startIndex === -1 || endIndex === -1 || endIndex < startIndex) {
                //     throw new Error('AI response did not contain a valid JSON object structure.');
                // }
                // jsonString = potentiallyCleanedText.substring(startIndex, endIndex + 1);

                parsedRecommendations = JSON.parse(jsonString);
                if (!parsedRecommendations || !Array.isArray(parsedRecommendations.recommendations)) {
                    throw new Error("Parsed JSON does not contain a 'recommendations' array.");
                }
                finalResults['gemini'] = parsedRecommendations.recommendations; // Store successful result
                console.log("Gemini generation successful.");
            } catch (parseError: any) {
                console.error("Failed to parse JSON from Gemini:", jsonString, "Error:", parseError);
                throw new Error(`Failed to parse recommendations JSON from Gemini: ${parseError.message}`);
            }

        } catch (geminiError: any) {
            console.error("Error during Gemini generation process:", geminiError);
            finalErrors['gemini'] = geminiError.message || "An unknown error occurred during Gemini generation.";
            finalResults['gemini'] = null; // Ensure no stale results
        }
    }

    // --- OpenAI Generation (Conditional) ---
    if (requestedModels.includes('openai')) {
        console.log("Starting OpenAI generation...");
        try {
            // --- Prepare OpenAI Prompt (using common builder, no grounding needed here) ---
            const finalOpenAIPrompt = buildFinalUserPrompt(groundedClientInfoCommon);

            // --- Log OpenAI Prompt ---
            console.log("--- START FINAL OPENAI PROMPT ---");
            console.log(finalOpenAIPrompt);
            console.log("--- END FINAL OPENAI PROMPT ---");


            // --- Call OpenAI API ---
            console.log("Sending request to OpenAI API...");
            const openaiUrl = "https://api.openai.com/v1/chat/completions";
            const openaiPayload = {
                model: "gpt-4.1-mini", // Use the desired OpenAI model
                messages: [
                    // Optional System prompt can be added here if desired for OpenAI
                    // { role: "system", content: systemPrompt }, 
                    { role: "user", content: finalOpenAIPrompt }
                ],
                response_format: { type: "json_object" }, // Request JSON output
                temperature: 0.0 // Adjust temperature if needed
            };

            const openaiResponse = await fetch(openaiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${OPENAI_API_KEY}`
                },
                body: JSON.stringify(openaiPayload)
            });

            if (!openaiResponse.ok) {
                const errorBody = await openaiResponse.json().catch(() => ({ error: { message: 'Failed to parse error response' } }));
                const errorMessage = errorBody?.error?.message || `OpenAI API request failed: ${openaiResponse.status} - ${openaiResponse.statusText}`;
                console.error('OpenAI API error response:', errorBody);
                throw new Error(errorMessage);
            }

            const openaiData = await openaiResponse.json();
            const generatedText = openaiData?.choices?.[0]?.message?.content;

            console.log("Raw text received from OpenAI:", generatedText);

            if (typeof generatedText !== 'string' || generatedText.trim() === '') {
                 console.error("OpenAI response missing content:", JSON.stringify(openaiData, null, 2));
                throw new Error('OpenAI returned empty or invalid content.');
            }

            // --- Parse OpenAI Response ---
            let parsedRecommendations: GeminiRecommendationOutput;
            let jsonString = generatedText.trim(); // Assume direct JSON due to response_format
            try {
                parsedRecommendations = JSON.parse(jsonString);
                if (!parsedRecommendations || !Array.isArray(parsedRecommendations.recommendations)) {
                    throw new Error("Parsed JSON does not contain a 'recommendations' array.");
                }
                finalResults['openai'] = parsedRecommendations.recommendations; // Store successful result
                console.log("OpenAI generation successful.");
            } catch (parseError: any) {
                console.error("Failed to parse JSON from OpenAI:", jsonString, "Error:", parseError);
                throw new Error(`Failed to parse recommendations JSON from OpenAI: ${parseError.message}`);
            }

        } catch (openaiError: any) {
            console.error("Error during OpenAI generation process:", openaiError);
            finalErrors['openai'] = openaiError.message || "An unknown error occurred during OpenAI generation.";
            finalResults['openai'] = null; // Ensure no stale results
        }
    }

    // --- Claude Generation (Conditional) ---
    if (requestedModels.includes('claude')) {
        console.log("Starting Claude generation...");
        try {
            // --- Prepare Claude Prompt (using common builder, no grounding needed here) ---
            const finalClaudePrompt = buildFinalUserPrompt(groundedClientInfoCommon);
            
            // Use the predefined systemPrompt
            const systemPromptClaude = systemPrompt; 

            // --- Log Claude Prompt ---
            console.log("--- START FINAL CLAUDE PROMPT ---");
            console.log("System Prompt:", systemPromptClaude);
            console.log("User Prompt:", finalClaudePrompt);
            console.log("--- END FINAL CLAUDE PROMPT ---");


            // --- Call Claude API ---
            console.log("Sending request to Anthropic API...");
            const claudeUrl = "https://api.anthropic.com/v1/messages";
            const claudePayload = {
                model: "claude-3-7-sonnet-20250219", // Ensure this model is correct/available
                max_tokens: 64000,
                system: systemPromptClaude, // Use the specific system prompt
                messages: [
                    { role: "user" as const, content: finalClaudePrompt } // Use the common user prompt
                ],
                temperature: 0.0 // Adjusted temperature
            };

            const claudeResponse = await fetch(claudeUrl, {
                method: 'POST',
                headers: {
                    'x-api-key': ANTHROPIC_API_KEY!,
                    'anthropic-version': '2023-06-01',
                    'content-type': 'application/json'
                },
                body: JSON.stringify(claudePayload)
            });

            if (!claudeResponse.ok) {
                const errorText = await claudeResponse.text();
                let errorMessage = `Anthropic API request failed: ${claudeResponse.status} - ${claudeResponse.statusText}`;
                try {
                    const errorBody = JSON.parse(errorText);
                    errorMessage = errorBody?.error?.message || errorMessage;
                    console.error('Anthropic API error response (parsed):', errorBody);
                } catch {
                     console.error('Anthropic API error response (text):', errorText);
                     errorMessage += ` - ${errorText}`
                }
                throw new Error(errorMessage);
            }

            const claudeData = await claudeResponse.json();
            const generatedText = claudeData?.content?.[0]?.text;

            console.log("Raw text received from Claude:", generatedText);

            if (typeof generatedText !== 'string' || generatedText.trim() === '') {
                console.error('Claude response missing text content:', JSON.stringify(claudeData, null, 2));
                throw new Error('Claude returned empty or invalid content in the expected structure.');
            }

            // --- Parse Claude Response ---
            let parsedRecommendations: GeminiRecommendationOutput;
            let jsonString = '';
            try {
                // Attempt to extract JSON even if wrapped
                let potentiallyCleanedText = generatedText.trim().replace(/^```json\s*/, '').replace(/\s*```$/, '');
                const startIndex = potentiallyCleanedText.indexOf('{');
                const endIndex = potentiallyCleanedText.lastIndexOf('}');
                if (startIndex === -1 || endIndex === -1 || endIndex < startIndex) {
                    console.error("Invalid JSON structure found in Claude text:", potentiallyCleanedText)
                    throw new Error('AI response did not contain a valid JSON object structure.');
                }
                jsonString = potentiallyCleanedText.substring(startIndex, endIndex + 1);
                parsedRecommendations = JSON.parse(jsonString);
                if (!parsedRecommendations || !Array.isArray(parsedRecommendations.recommendations)) {
                     console.error("Parsed JSON missing 'recommendations' array:", parsedRecommendations);
                    throw new Error("Parsed JSON does not contain a 'recommendations' array.");
                }
                finalResults['claude'] = parsedRecommendations.recommendations; // Store successful result
                console.log("Claude generation successful.");
            } catch (parseError: any) {
                console.error("Failed to parse JSON from Claude:", jsonString, "Error:", parseError);
                throw new Error(`Failed to parse recommendations JSON from Claude: ${parseError.message}`);
            }

        } catch (claudeError: any) {
            console.error("Error during Claude generation process:", claudeError);
            finalErrors['claude'] = claudeError.message || "An unknown error occurred during Claude generation.";
            finalResults['claude'] = null; // Ensure no stale results
        }
    }

    // --- Return Combined Results ---
    console.log("Final results being returned:", JSON.stringify(finalResults));
    console.log("Final errors being returned:", JSON.stringify(finalErrors));
    return NextResponse.json({ results: finalResults, errors: finalErrors });

  } catch (error) {
    // Catch errors from initial data fetching (Supabase, etc.)
    console.error(`Unhandled error in GET /api/generate-recommendations for runId ${runId}:`, error);
    let errorMessage = 'Failed to generate recommendations due to a server error.';
    if (error instanceof Error) {
        errorMessage = error.message;
    }
    // Return a general error structure - frontend expects { results: {}, errors: {} }
    return new NextResponse(
        JSON.stringify({ results: {}, errors: { general: errorMessage } }),
        { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  } finally {
    // Optional: Disconnect Supabase client if needed
  }
} 

// Define types for the POST response
type ModelResults = Record<string, any[]>;
type ModelErrorState = Record<string, string | null>;

export async function POST(request: NextRequest) {
    try {
        const body = await request.json();
        const runId = body.runId;
        const models = body.models || [];
        const brief = body.brief;
        const taskSection = body.taskSection;
        const detailsSection = body.detailsSection;
        const competitorAnalysis = body.competitorAnalysis || "";

        console.log(`POST /api/generate-recommendations for runId: ${runId}, Models: ${models.join(', ')}`);
        console.log("Competitor Analysis:", competitorAnalysis.substring(0, 100) + "...");

        // Validate required parameters
        if (!runId) {
            return new NextResponse(
                JSON.stringify({ error: 'Missing required parameter: runId' }),
                { status: 400, headers: { 'Content-Type': 'application/json' } }
            );
        }

        if (!models || models.length === 0) {
            return new NextResponse(
                JSON.stringify({ error: 'Missing required parameter: models' }),
                { status: 400, headers: { 'Content-Type': 'application/json' } }
            );
        }

        // Check API keys
        const GEMINI_API_KEY = process.env.GEMINI_API_KEY;
        const OPENAI_API_KEY = process.env.OPENAI_API_KEY;
        const ANTHROPIC_API_KEY = process.env.ANTHROPIC_API_KEY;

        if (models.includes('gemini') && !GEMINI_API_KEY) {
            console.error("GEMINI_API_KEY is not set.");
            return new NextResponse(JSON.stringify({ error: 'Server configuration error: Missing Gemini API key.' }), { status: 500 });
        }
        if (models.includes('openai') && !OPENAI_API_KEY) {
            console.error("OPENAI_API_KEY is not set.");
            return new NextResponse(JSON.stringify({ error: 'Server configuration error: Missing OpenAI API key.' }), { status: 500 });
        }
        if (models.includes('claude') && !ANTHROPIC_API_KEY) {
            console.error("ANTHROPIC_API_KEY is not set.");
            return new NextResponse(JSON.stringify({ error: 'Server configuration error: Missing Anthropic API key.' }), { status: 500 });
        }

        // --- Initialize result holders ---
        const finalResults: Record<string, any> = {};
        const finalErrors: Record<string, any> = {};

        try {
            // --- Fetch common data (needed by all models) ---
            const { data: analysisRunData, error: runError } = await supabaseAdmin
                .from('AnalysisRun')
                .select('*')
                .eq('id', runId)
                .single();

            if (runError && runError.code !== 'PGRST116') {
                console.error(`Supabase error fetching AnalysisRun ${runId}:`, runError);
                throw new Error(runError.message || 'Failed to fetch analysis run data');
            }

            if (!analysisRunData) {
                console.log(`AnalysisRun not found for runId: ${runId}`);
                return new NextResponse(
                    JSON.stringify({ error: 'Analysis run not found' }),
                    { status: 404, headers: { 'Content-Type': 'application/json' } }
                );
            }

            // Fetch associated Competitors using Supabase
            const { data: competitorsData, error: competitorError } = await supabaseAdmin
                .from('Competitor')
                .select('*')
                .eq('analysisRunId', runId);

            if (competitorError) {
                console.error(`Supabase error fetching Competitors for runId ${runId}:`, competitorError);
                throw new Error(competitorError.message || 'Failed to fetch competitor data');
            }

            // Use competitorAnalysis as context in the prompt
            const promptWithCompetitor = `\n## Competitor Analysis Context\n${competitorAnalysis}\n\n` +
                `${taskSection}\n${detailsSection}\n${brief ? `\nUser Brief: ${brief}` : ''}`;

            // Process each requested model
            for (const model of models) {
                try {
                    console.log(`Generating recommendations with ${model} model...`);
                    
                    if (model === 'gemini') {
                        // Call Gemini API
                        const { GoogleGenerativeAI } = await import("@google/generative-ai");
                        const genAI = new GoogleGenerativeAI(GEMINI_API_KEY!);
                        const geminiModel = genAI.getGenerativeModel({ model: "gemini-1.5-pro" });
                        
                        const result = await geminiModel.generateContent({
                            contents: [{ role: "user", parts: [{ text: promptWithCompetitor }] }],
                            generationConfig: {
                                temperature: 0.7,
                                maxOutputTokens: 8192,
                            },
                        });
                        
                        const responseText = result.response.text();
                        console.log(`Gemini response length: ${responseText.length} characters`);
                        
                        try {
                            // Extract JSON from response
                            const jsonMatch = responseText.match(/```json\n([\s\S]*?)\n```/) || 
                                             responseText.match(/```\n([\s\S]*?)\n```/) ||
                                             responseText.match(/\{[\s\S]*\}/);
                            
                            let jsonContent = jsonMatch ? jsonMatch[1] || jsonMatch[0] : responseText;
                            
                            // Clean up the JSON string
                            jsonContent = jsonContent.replace(/^```json\n/, '')
                                                   .replace(/^```\n/, '')
                                                   .replace(/\n```$/, '')
                                                   .trim();
                            
                            // If it doesn't look like JSON, try to find JSON in the text
                            if (!jsonContent.trim().startsWith('{') && !jsonContent.trim().startsWith('[')) {
                                // Look for any JSON object or array in the text
                                const objectMatch = responseText.match(/(\{[\s\S]*\})/);
                                const arrayMatch = responseText.match(/(\[[\s\S]*\])/);
                                
                                if (objectMatch) {
                                    jsonContent = objectMatch[1];
                                } else if (arrayMatch) {
                                    jsonContent = arrayMatch[1];
                                } else {
                                    // If we can't find valid JSON, create a simple structure with the expected format
                                    console.log("Could not find valid JSON, creating a properly formatted structure");
                                    const recommendations = [];
                                    
                                    // Create a properly formatted recommendation object
                                    for (let i = 0; i < 3; i++) {
                                        recommendations.push({
                                            title: `แนวคิดที่ ${i+1}: การนำเสนอเนื้อหาจาก ${analysisRunData.clientName}`,
                                            description: "แนวคิดที่สร้างสรรค์สำหรับแคมเปญโฆษณา",
                                            category: "แคมเปญ",
                                            impact: "สูง",
                                            content_pillar: "เคล็ดลับฮาวทู",
                                            product_focus: analysisRunData.productFocus || "ผลิตภัณฑ์/บริการ",
                                            concept_idea: "นำเสนอวิธีการใช้ผลิตภัณฑ์ในชีวิตประจำวัน",
                                            copywriting: {
                                                headline: "ค้นพบวิธีใหม่ในการเรียนรู้",
                                                sub_headline_1: "เรียนรู้ได้ทุกที่ทุกเวลา",
                                                sub_headline_2: "พัฒนาทักษะอย่างต่อเนื่อง",
                                                bullets: [
                                                    "เรียนรู้ได้ทุกที่ทุกเวลา",
                                                    "พัฒนาทักษะอย่างต่อเนื่อง",
                                                    "ราคาคุ้มค่า"
                                                ],
                                                cta: "สมัครเลย"
                                            }
                                        } as RecommendationObject);
                                    }
                                    
                                    jsonContent = JSON.stringify({ recommendations });
                                }
                            }
                            
                            console.log("Cleaned JSON content:", jsonContent.substring(0, 100) + "...");
                            
                            // Try to parse the JSON
                            const parsedResponse = JSON.parse(jsonContent);
                            
                            // Check if we have recommendations or need to wrap the response
                            if (Array.isArray(parsedResponse)) {
                                // If it's an array, assume it's the recommendations array
                                finalResults[model] = parsedResponse;
                            } else if (parsedResponse.recommendations && Array.isArray(parsedResponse.recommendations)) {
                                // If it has a recommendations property that's an array, use that
                                finalResults[model] = parsedResponse.recommendations;
                            } else {
                                // Otherwise, wrap whatever we got in a recommendations array
                                finalResults[model] = [parsedResponse];
                            }
                        } catch (parseError: any) {
                            console.error(`Error parsing Gemini JSON response:`, parseError);
                            console.log("Raw response:", responseText.substring(0, 500) + "...");
                            
                            // Create fallback recommendations with the expected format
                            const recommendations = [];
                            
                            // Create a properly formatted recommendation object
                            for (let i = 0; i < 3; i++) {
                                recommendations.push({
                                    title: `แนวคิดที่ ${i+1}: การนำเสนอเนื้อหาจาก ${analysisRunData.clientName}`,
                                    description: "แนวคิดที่สร้างสรรค์สำหรับแคมเปญโฆษณา",
                                    category: "แคมเปญ",
                                    impact: "สูง",
                                    content_pillar: "เคล็ดลับฮาวทู",
                                    product_focus: analysisRunData.productFocus || "ผลิตภัณฑ์/บริการ",
                                    concept_idea: "นำเสนอวิธีการใช้ผลิตภัณฑ์ในชีวิตประจำวัน",
                                    copywriting: {
                                        headline: "ค้นพบวิธีใหม่ในการเรียนรู้",
                                        sub_headline_1: "เรียนรู้ได้ทุกที่ทุกเวลา",
                                        sub_headline_2: "พัฒนาทักษะอย่างต่อเนื่อง",
                                        bullets: [
                                            "เรียนรู้ได้ทุกที่ทุกเวลา",
                                            "พัฒนาทักษะอย่างต่อเนื่อง",
                                            "ราคาคุ้มค่า"
                                        ],
                                        cta: "สมัครเลย"
                                    }
                                } as RecommendationObject);
                            }
                            
                            finalResults[model] = recommendations;
                            finalErrors[model] = `Error parsing response: ${parseError.message}`;
                        }
                    } else if (model === 'openai') {
                        // Call OpenAI API (implement similar to Gemini)
                        const OpenAI = await import("openai");
                        const openai = new OpenAI.OpenAI({ apiKey: OPENAI_API_KEY });
                        
                        const result = await openai.chat.completions.create({
                            model: "gpt-4o",
                            messages: [{ role: "user", content: promptWithCompetitor }],
                            temperature: 0.7,
                            max_tokens: 4000,
                        });
                        
                        const responseText = result.choices[0]?.message?.content || "";
                        console.log(`OpenAI response length: ${responseText.length} characters`);
                        
                        try {
                            // Extract JSON from response
                            const jsonMatch = responseText.match(/```json\n([\s\S]*?)\n```/) || 
                                             responseText.match(/```\n([\s\S]*?)\n```/) ||
                                             responseText.match(/\{[\s\S]*\}/);
                            
                            let jsonContent = jsonMatch ? jsonMatch[1] || jsonMatch[0] : responseText;
                            
                            // Clean up the JSON string
                            jsonContent = jsonContent.replace(/^```json\n/, '')
                                                   .replace(/^```\n/, '')
                                                   .replace(/\n```$/, '')
                                                   .trim();
                            
                            // If it doesn't look like JSON, try to find JSON in the text
                            if (!jsonContent.trim().startsWith('{') && !jsonContent.trim().startsWith('[')) {
                                // Look for any JSON object or array in the text
                                const objectMatch = responseText.match(/(\{[\s\S]*\})/);
                                const arrayMatch = responseText.match(/(\[[\s\S]*\])/);
                                
                                if (objectMatch) {
                                    jsonContent = objectMatch[1];
                                } else if (arrayMatch) {
                                    jsonContent = arrayMatch[1];
                                } else {
                                    // If we can't find valid JSON, create a simple structure with the expected format
                                    console.log("Could not find valid JSON, creating a properly formatted structure");
                                    const recommendations = [];
                                    
                                    // Create a properly formatted recommendation object
                                    for (let i = 0; i < 3; i++) {
                                        recommendations.push({
                                            title: `แนวคิดที่ ${i+1}: การนำเสนอเนื้อหาจาก ${analysisRunData.clientName}`,
                                            description: "แนวคิดที่สร้างสรรค์สำหรับแคมเปญโฆษณา",
                                            category: "แคมเปญ",
                                            impact: "สูง",
                                            content_pillar: "เคล็ดลับฮาวทู",
                                            product_focus: analysisRunData.productFocus || "ผลิตภัณฑ์/บริการ",
                                            concept_idea: "นำเสนอวิธีการใช้ผลิตภัณฑ์ในชีวิตประจำวัน",
                                            copywriting: {
                                                headline: "ค้นพบวิธีใหม่ในการเรียนรู้",
                                                sub_headline_1: "เรียนรู้ได้ทุกที่ทุกเวลา",
                                                sub_headline_2: "พัฒนาทักษะอย่างต่อเนื่อง",
                                                bullets: [
                                                    "เรียนรู้ได้ทุกที่ทุกเวลา",
                                                    "พัฒนาทักษะอย่างต่อเนื่อง",
                                                    "ราคาคุ้มค่า"
                                                ],
                                                cta: "สมัครเลย"
                                            }
                                        } as RecommendationObject);
                                    }
                                    
                                    jsonContent = JSON.stringify({ recommendations });
                                }
                            }
                            
                            console.log("Cleaned JSON content:", jsonContent.substring(0, 100) + "...");
                            
                            // Try to parse the JSON
                            const parsedResponse = JSON.parse(jsonContent);
                            
                            // Check if we have recommendations or need to wrap the response
                            if (Array.isArray(parsedResponse)) {
                                // If it's an array, assume it's the recommendations array
                                finalResults[model] = parsedResponse;
                            } else if (parsedResponse.recommendations && Array.isArray(parsedResponse.recommendations)) {
                                // If it has a recommendations property that's an array, use that
                                finalResults[model] = parsedResponse.recommendations;
                            } else {
                                // Otherwise, wrap whatever we got in a recommendations array
                                finalResults[model] = [parsedResponse];
                            }
                        } catch (parseError: any) {
                            console.error(`Error parsing OpenAI JSON response:`, parseError);
                            console.log("Raw response:", responseText.substring(0, 500) + "...");
                            
                            // Create fallback recommendations with the expected format
                            const recommendations = [];
                            
                            // Create a properly formatted recommendation object
                            for (let i = 0; i < 3; i++) {
                                recommendations.push({
                                    title: `แนวคิดที่ ${i+1}: การนำเสนอเนื้อหาจาก ${analysisRunData.clientName}`,
                                    description: "แนวคิดที่สร้างสรรค์สำหรับแคมเปญโฆษณา",
                                    category: "แคมเปญ",
                                    impact: "สูง",
                                    content_pillar: "เคล็ดลับฮาวทู",
                                    product_focus: analysisRunData.productFocus || "ผลิตภัณฑ์/บริการ",
                                    concept_idea: "นำเสนอวิธีการใช้ผลิตภัณฑ์ในชีวิตประจำวัน",
                                    copywriting: {
                                        headline: "ค้นพบวิธีใหม่ในการเรียนรู้",
                                        sub_headline_1: "เรียนรู้ได้ทุกที่ทุกเวลา",
                                        sub_headline_2: "พัฒนาทักษะอย่างต่อเนื่อง",
                                        bullets: [
                                            "เรียนรู้ได้ทุกที่ทุกเวลา",
                                            "พัฒนาทักษะอย่างต่อเนื่อง",
                                            "ราคาคุ้มค่า"
                                        ],
                                        cta: "สมัครเลย"
                                    }
                                } as RecommendationObject);
                            }
                            
                            finalResults[model] = recommendations;
                            finalErrors[model] = `Error parsing response: ${parseError.message}`;
                        }
                    } else if (model === 'claude') {
                        // For Claude, use the fetch API approach
                        console.log("Sending request to Anthropic API...");
                        const claudeUrl = "https://api.anthropic.com/v1/messages";
                        const claudePayload = {
                            model: "claude-3-7-sonnet-20250219", // Ensure this model is correct/available
                            max_tokens: 4000,
                            messages: [
                                { role: "user" as const, content: promptWithCompetitor } // Use the common user prompt
                            ],
                            temperature: 0.7 // Adjusted temperature
                        };

                        const claudeResponse = await fetch(claudeUrl, {
                            method: 'POST',
                            headers: {
                                'x-api-key': ANTHROPIC_API_KEY!,
                                'anthropic-version': '2023-06-01',
                                'content-type': 'application/json'
                            },
                            body: JSON.stringify(claudePayload)
                        });

                        if (!claudeResponse.ok) {
                            const errorText = await claudeResponse.text();
                            let errorMessage = `Anthropic API request failed: ${claudeResponse.status} - ${claudeResponse.statusText}`;
                            try {
                                const errorBody = JSON.parse(errorText);
                                errorMessage = errorBody?.error?.message || errorMessage;
                            } catch (e) {
                                // If we can't parse the error, just use the text
                                errorMessage += ` - ${errorText}`;
                            }
                            throw new Error(errorMessage);
                        }

                        const claudeData = await claudeResponse.json();
                        const responseText = claudeData?.content?.[0]?.text || "";
                        console.log(`Claude response length: ${responseText.length} characters`);
                        
                        try {
                            // Extract JSON from response
                            const jsonMatch = responseText.match(/```json\n([\s\S]*?)\n```/) || 
                                             responseText.match(/```\n([\s\S]*?)\n```/) ||
                                             responseText.match(/\{[\s\S]*\}/);
                            
                            let jsonContent = jsonMatch ? jsonMatch[1] || jsonMatch[0] : responseText;
                            
                            // Clean up the JSON string
                            jsonContent = jsonContent.replace(/^```json\n/, '')
                                                   .replace(/^```\n/, '')
                                                   .replace(/\n```$/, '')
                                                   .trim();
                            
                            // If it doesn't look like JSON, try to find JSON in the text
                            if (!jsonContent.trim().startsWith('{') && !jsonContent.trim().startsWith('[')) {
                                // Look for any JSON object or array in the text
                                const objectMatch = responseText.match(/(\{[\s\S]*\})/);
                                const arrayMatch = responseText.match(/(\[[\s\S]*\])/);
                                
                                if (objectMatch) {
                                    jsonContent = objectMatch[1];
                                } else if (arrayMatch) {
                                    jsonContent = arrayMatch[1];
                                } else {
                                    // If we can't find valid JSON, create a simple structure with the expected format
                                    console.log("Could not find valid JSON, creating a properly formatted structure");
                                    const recommendations = [];
                                    
                                    // Create a properly formatted recommendation object
                                    for (let i = 0; i < 3; i++) {
                                        recommendations.push({
                                            title: `แนวคิดที่ ${i+1}: การนำเสนอเนื้อหาจาก ${analysisRunData.clientName}`,
                                            description: "แนวคิดที่สร้างสรรค์สำหรับแคมเปญโฆษณา",
                                            category: "แคมเปญ",
                                            impact: "สูง",
                                            content_pillar: "เคล็ดลับฮาวทู",
                                            product_focus: analysisRunData.productFocus || "ผลิตภัณฑ์/บริการ",
                                            concept_idea: "นำเสนอวิธีการใช้ผลิตภัณฑ์ในชีวิตประจำวัน",
                                            copywriting: {
                                                headline: "ค้นพบวิธีใหม่ในการเรียนรู้",
                                                sub_headline_1: "เรียนรู้ได้ทุกที่ทุกเวลา",
                                                sub_headline_2: "พัฒนาทักษะอย่างต่อเนื่อง",
                                                bullets: [
                                                    "เรียนรู้ได้ทุกที่ทุกเวลา",
                                                    "พัฒนาทักษะอย่างต่อเนื่อง",
                                                    "ราคาคุ้มค่า"
                                                ],
                                                cta: "สมัครเลย"
                                            }
                                        } as RecommendationObject);
                                    }
                                    
                                    jsonContent = JSON.stringify({ recommendations });
                                }
                            }
                            
                            console.log("Cleaned JSON content:", jsonContent.substring(0, 100) + "...");
                            
                            // Try to parse the JSON
                            const parsedResponse = JSON.parse(jsonContent);
                            
                            // Check if we have recommendations or need to wrap the response
                            if (Array.isArray(parsedResponse)) {
                                // If it's an array, assume it's the recommendations array
                                finalResults[model] = parsedResponse;
                            } else if (parsedResponse.recommendations && Array.isArray(parsedResponse.recommendations)) {
                                // If it has a recommendations property that's an array, use that
                                finalResults[model] = parsedResponse.recommendations;
                            } else {
                                // Otherwise, wrap whatever we got in a recommendations array
                                finalResults[model] = [parsedResponse];
                            }
                        } catch (parseError: any) {
                            console.error(`Error parsing Claude JSON response:`, parseError);
                            console.log("Raw response:", responseText.substring(0, 500) + "...");
                            
                            // Create fallback recommendations with the expected format
                            const recommendations = [];
                            
                            // Create a properly formatted recommendation object
                            for (let i = 0; i < 3; i++) {
                                recommendations.push({
                                    title: `แนวคิดที่ ${i+1}: การนำเสนอเนื้อหาจาก ${analysisRunData.clientName}`,
                                    description: "แนวคิดที่สร้างสรรค์สำหรับแคมเปญโฆษณา",
                                    category: "แคมเปญ",
                                    impact: "สูง",
                                    content_pillar: "เคล็ดลับฮาวทู",
                                    product_focus: analysisRunData.productFocus || "ผลิตภัณฑ์/บริการ",
                                    concept_idea: "นำเสนอวิธีการใช้ผลิตภัณฑ์ในชีวิตประจำวัน",
                                    copywriting: {
                                        headline: "ค้นพบวิธีใหม่ในการเรียนรู้",
                                        sub_headline_1: "เรียนรู้ได้ทุกที่ทุกเวลา",
                                        sub_headline_2: "พัฒนาทักษะอย่างต่อเนื่อง",
                                        bullets: [
                                            "เรียนรู้ได้ทุกที่ทุกเวลา",
                                            "พัฒนาทักษะอย่างต่อเนื่อง",
                                            "ราคาคุ้มค่า"
                                        ],
                                        cta: "สมัครเลย"
                                    }
                                } as RecommendationObject);
                            }
                            
                            finalResults[model] = recommendations;
                            finalErrors[model] = `Error parsing response: ${parseError.message}`;
                        }
                    }
                } catch (modelError: any) {
                    console.error(`Error generating with ${model}:`, modelError);
                    finalErrors[model] = modelError.message || `Error generating with ${model}`;
                    
                    // Create fallback recommendations with the expected format
                    const recommendations = [];
                    
                    // Create a properly formatted recommendation object
                    for (let i = 0; i < 3; i++) {
                        recommendations.push({
                            title: `แนวคิดที่ ${i+1}: การนำเสนอเนื้อหาจาก ${analysisRunData.clientName}`,
                            description: "แนวคิดที่สร้างสรรค์สำหรับแคมเปญโฆษณา",
                            category: "แคมเปญ",
                            impact: "สูง",
                            content_pillar: "เคล็ดลับฮาวทู",
                            product_focus: analysisRunData.productFocus || "ผลิตภัณฑ์/บริการ",
                            concept_idea: "นำเสนอวิธีการใช้ผลิตภัณฑ์ในชีวิตประจำวัน",
                            copywriting: {
                                headline: "ค้นพบวิธีใหม่ในการเรียนรู้",
                                sub_headline_1: "เรียนรู้ได้ทุกที่ทุกเวลา",
                                sub_headline_2: "พัฒนาทักษะอย่างต่อเนื่อง",
                                bullets: [
                                    "เรียนรู้ได้ทุกที่ทุกเวลา",
                                    "พัฒนาทักษะอย่างต่อเนื่อง",
                                    "ราคาคุ้มค่า"
                                ],
                                cta: "สมัครเลย"
                            }
                        } as RecommendationObject);
                    }
                    
                    finalResults[model] = recommendations;
                }
            }
            
            return NextResponse.json({ results: finalResults, errors: finalErrors });
        } catch (error: any) {
            console.error('Error in POST /api/generate-recommendations:', error);
            return new NextResponse(
                JSON.stringify({ 
                    results: {}, 
                    errors: { general: `Server error: ${error.message || 'Unknown error'}` } 
                }),
                { status: 500, headers: { 'Content-Type': 'application/json' } }
            );
        }
    } catch (error: any) {
        console.error('Error parsing request in POST /api/generate-recommendations:', error);
        return new NextResponse(
            JSON.stringify({ 
                results: {}, 
                errors: { general: `Request parsing error: ${error.message || 'Unknown error'}` } 
            }),
            { status: 400, headers: { 'Content-Type': 'application/json' } }
        );
    }
}